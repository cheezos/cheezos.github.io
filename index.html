<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home of Cheezos</title>
    <link rel="icon" href="public/images/icon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            /* background: #050505; */ /* Removed: Will be set dynamically */
            overflow: hidden;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="vortex"></canvas>
    <script type="text/javascript">
        // === CONFIGURABLE CONSTANTS ===
        const CANVAS_SIZE_MULTIPLIER = 1.0;
        const SPAWN_RADIUS_EXTRA = 50;
        const SPAWN_DURATION = 1000;
        const SIZE_LEVELS = 10;
        const HUE_LEVELS = 1; // Reduced from 6 (Only base color)
        const STAR_HUE_LEVELS = 1; // Reduced from 3 (Only base color)
        const MIN_ALPHA = 0.0;
        const MAX_ALPHA = 0.8;
        const ALPHA_FADE_RADIUS = 0.2;
        const STAR_WEIGHT = 500;
        const OTHER_EMOJI_WEIGHT = 1;
        const PARTICLE_SPEED_MIN = 20;
        const PARTICLE_PERP_SPEED = 5;
        const PARTICLE_INITIAL_ANGLE_OFFSET = Math.PI / 8; // Increased from PI / 12 (15deg -> 22.5deg)
        const PARTICLE_MIN_DIST = 120;
        const PARTICLE_GRAVITY = 80000000;
        const PARTICLE_MAX_VEL = 250;
        const PARTICLE_MIN_ABS_SPEED = 5; // Increased minimum speed from 1.5
        const PARTICLE_MIN_MASS = 0.5; // Added: Minimum mass multiplier
        const PARTICLE_MAX_MASS = 1.5; // Added: Maximum mass multiplier
        const PARTICLE_OUT_BOUNDS = 200;
        const NOTIFICATION_DURATION = 2000;
        const UI_FONT_STYLE = '16px Arial, sans-serif';
        const HINT_X = 10;
        const HINT_Y1 = 10;
        const HINT_Y2 = 30;
        const TARGET_POINT_STEP = 4;
        const TARGET_POINT_MIN_DIST = 5;
        const TARGET_POINT_ALPHA_THRESHOLD = 128;
        const NOTIFICATION_STACK_Y = 50;
        const NOTIFICATION_STACK_STEP = 20;
        const DEBUG_LINE_COLOR = 'lime';
        const DEBUG_LINE_WIDTH = 2;
        const RESPONSIVE_FONT_MIN = 24;
        const RESPONSIVE_FONT_MULTIPLIER = 0.5;
        const SCHEDULE_UPDATE_BUFFER = 50;
        const ALPHA_TRANSITION_DURATION = 1500; // Duration for alpha transition in ms (e.g., 1.5 seconds)
        const MOBILE_WIDTH_THRESHOLD = 992; // Increased threshold for vertical time display (was 768)

        // Starfield constants
        const NUM_STARS = 300;
        const STAR_MIN_SIZE = 0.5;
        const STAR_MAX_SIZE = 2;
        const STAR_MIN_SPEED = 1;
        const STAR_MAX_SPEED = 4;

        // Particle specific constants
        const STAR_PARTICLE_SCALE_FACTOR = 0.4; // Stars will be 60% of the normal size
        const MOON_PARTICLE_SCALE_FACTOR = 1.0; // Moons are base size
        const PLANET_PARTICLE_SCALE_FACTOR = 1.5; // Planets are larger
        const STAR_TWINKLE_AMOUNT = 0.4; // How much star alpha varies (0 to 1)

        // Patreon Link Integration
        const PATREON_URL = 'https://www.patreon.com/c/cheezos/'; // <<< --- UPDATED URL
        const PATREON_ORANGE = '#FF424D';
        const PATREON_PARTICLE_INDEX = 0; // Particle at index 0 will be the Patreon link
        const PATREON_SCALE_FACTOR = 1.125; // Reduced size by 25% (was 1.5)
        const PATREON_MAX_ALPHA = 1.0; // Patreon particle max alpha
        const PATREON_TRAIL_LENGTH = 20; // Reduced from 30
        const PATREON_SPAWN_DELAY = 10000; // 10-second spawn delay in milliseconds
        const PATREON_HITBOX_PADDING = 20; // Extra pixels added to each side for easier clicking/tapping

        // Mouse interaction constants
        const MOUSE_INTERACTION_RADIUS = 50; // How close the pointer needs to be
        const MOUSE_REPEL_STRENGTH = 10000000; // How strongly other particles are pushed
        const MOUSE_ATTRACT_STRENGTH = 50; // How strongly the Patreon particle is pulled (Lower value for gentler pull)

        // Dynamic Damping Constants
        const DAMPING_FACTOR_MOBILE = 0.98;  // Increased damping (was 0.995)
        const DAMPING_FACTOR_DESKTOP = 0.99; // Increased damping (was 0.998)
        const DAMPING_SCALE_MIN_DIM = 320;    // Smallest dimension for scaling start
        const DAMPING_SCALE_MAX_DIM = 1200;   // Dimension where scaling reaches desktop value

        // Particle Collision Constants
        const COLLISION_REPEL_STRENGTH = 1000; // How strongly particles push each other
        const COLLISION_DISTANCE_FACTOR = 0.8; // Factor of sum of radii to trigger collision ( < 1 allows some visual overlap)

        // Time Change Transition Constants
        const TIME_CHANGE_FADE_DURATION = 1000; // Duration of fade out in ms

        // === END CONFIGURABLE CONSTANTS ===

        // Global variables that will be calculated dynamically
        let MAX_PARTICLES;
        let MIN_SIZE;
        let MAX_SIZE;
        let emojiVariantCache;
        let isCacheReady = false;
        let currentHourForCache = -1; // Track hour used for cache generation
        let currentTimeHueShift = 0; // Store the current hue shift value
        let currentDampingFactor = DAMPING_FACTOR_DESKTOP; // Initialize with default

        // Time Change State
        let isFadingOutForTimeChange = false;
        let fadeOutStartTime = 0;

        // Space/planet-themed emojis (all planets + Pluto + Sun + Moon + Star)
        const emojis = [
            '🌕', // Full Moon
            '🌍', // Earth
            '🌎', // Earth Americas
            '🌏', // Earth Asia-Australia
            '🪐', // Saturn
            '⭐', // Star
            'public/images/icon.png'  // Patreon Logo Path
        ];
        const STAR_INDEX = emojis.indexOf('⭐');
        const MOON_INDEX = emojis.indexOf('🌕');
        const PATREON_INDEX = emojis.indexOf('public/images/icon.png');

        const emojiWeights = emojis.map((e, i) => {
            if (i === PATREON_INDEX) return 0; // Patreon particle is not randomly selected
            if (i === STAR_INDEX) return STAR_WEIGHT;
            return OTHER_EMOJI_WEIGHT;
        });
        const weightedEmojiIndices = []; // Used for non-Patreon particles
        for (let i = 0; i < emojis.length; i++) {
            // Only add non-Patreon emojis based on weight
            if (i !== PATREON_INDEX) { 
                for (let w = 0; w < emojiWeights[i]; w++) {
                    weightedEmojiIndices.push(i);
                }
            }
        }
    </script>
    <script>
        const canvas = document.getElementById('vortex');
        const ctx = canvas.getContext('2d');

        // Declare global state variables
        let targetPoints = [];
        let gravityEnabled = true; // Target points gravity enabled by default
        let notifications = [];
        let hideUI = true;
        let centerX, centerY, spawnRadius;
        let startTime = null;
        let lastTime = 0;
        let debugParticleIndex = null;
        const particles = [];
        const stars = []; // Array to hold star data
        let patreonParticleSpawned = false; // Flag to track if Patreon particle is configured

        // Mouse tracking for hover effects
        let mouseX = -1;
        let mouseY = -1;
        let isHoveringPatreon = false; // Track hover state

        // Notification class for temporary messages
        class Notification {
            constructor(text, duration = NOTIFICATION_DURATION) {
                this.text = text;
                this.duration = duration; // Duration in milliseconds
                this.startTime = Date.now();
            }

            isExpired() {
                return (Date.now() - this.startTime) > this.duration;
            }

            draw(index) {
                ctx.save();
                ctx.font = UI_FONT_STYLE;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                // Display below the hint text, stacked vertically
                ctx.fillText(this.text, HINT_X, NOTIFICATION_STACK_Y + index * NOTIFICATION_STACK_STEP);
                ctx.restore();
            }
        }

        // Resize canvas to fit window
        function resizeCanvas() {
            // Increase canvas size by multiplier in both dimensions
            canvas.width = window.innerWidth * CANVAS_SIZE_MULTIPLIER;
            canvas.height = window.innerHeight * CANVAS_SIZE_MULTIPLIER;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            spawnRadius = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) / 2 + SPAWN_RADIUS_EXTRA;

            // --- Dynamic Calculation based on Screen Size ---
            const minDimension = Math.min(canvas.width, canvas.height);

            // Adjust MAX_PARTICLES based on screen size (e.g., proportional to minDimension)
            isCacheReady = false;
            MAX_PARTICLES = Math.max(100, Math.min(600, Math.floor(100 + minDimension * 0.3)));

             // Adjust MIN_SIZE and MAX_SIZE based on screen size
            // Example scaling: Slightly smaller on smaller screens. Adjust factors as needed.
            MIN_SIZE = Math.max(10, Math.floor(minDimension * 0.015));
            MAX_SIZE = Math.max(15, Math.floor(minDimension * 0.025));
            // --- End Dynamic Calculation ---

            // --- Calculate Dynamic Damping --- 
            const t = Math.max(0, Math.min(1, (minDimension - DAMPING_SCALE_MIN_DIM) / (DAMPING_SCALE_MAX_DIM - DAMPING_SCALE_MIN_DIM)));
            currentDampingFactor = DAMPING_FACTOR_MOBILE + t * (DAMPING_FACTOR_DESKTOP - DAMPING_FACTOR_MOBILE);
            // console.log(`minDim: ${minDimension.toFixed(0)}, t: ${t.toFixed(2)}, damping: ${currentDampingFactor.toFixed(4)}`); // Debug log
            // --- End Dynamic Damping Calculation ---

            // Re-generate blur cache since sizes changed, using the current time hue shift
            makeEmojiVariantCache();
            // Recompute target points on resize
            computeTargetPoints();
            // Recreate stars for the new size
            createStars();
            // Update each particle's sun (target point)
            particles.forEach(p => {
                if (targetPoints.length > 0) {
                    const randomIndex = Math.floor(Math.random() * targetPoints.length);
                    p.sun = targetPoints[randomIndex];
                } else {
                    p.sun = { x: centerX, y: centerY };
                }
            });
        }

        // Pre-render blurred, sized, and hue-rotated emoji variants
        function makeEmojiVariantCache(baseHueShift = 0) {
            // Indicate cache is not ready during regeneration
            isCacheReady = false;
            console.time('makeEmojiVariantCache'); // Add timing
            const cache = [];
            // const isNight = new Date().getHours() >= 20 || new Date().getHours() < 6; // Removed Day/Night check

            // Revert to original hue steps/ranges
            const hueStep = HUE_LEVELS > 1 ? 360 / HUE_LEVELS : 0;
            const starHueMin = 60; // Original fixed range
            const starHueMax = 210; // Original fixed range
            const starHueStep = (STAR_HUE_LEVELS > 1) ? (starHueMax - starHueMin) / (STAR_HUE_LEVELS - 1) : 0;

            const imagePromises = []; // Store promises for image loading

            for (let e = 0; e < emojis.length; e++) {
                const emojiOrPath = emojis[e];
                const isStar = (e === STAR_INDEX);
                const isPatreon = (e === PATREON_INDEX);
                const isImagePath = typeof emojiOrPath === 'string' && (emojiOrPath.endsWith('.png') || emojiOrPath.endsWith('.jpg') || emojiOrPath.endsWith('.svg')); // Basic check

                if (isImagePath) {
                    // Preload the image
                    const img = new Image();
                    const promise = new Promise((resolve, reject) => {
                        img.onload = () => resolve({ img, index: e });
                        img.onerror = reject;
                        img.src = emojiOrPath;
                    });
                    imagePromises.push(promise);
                }
            }

            // Wait for all images to load before proceeding with cache generation
            Promise.all(imagePromises).then(loadedImagesData => {
                const loadedImages = {};
                loadedImagesData.forEach(data => {
                    loadedImages[data.index] = data.img;
                });

                for (let e = 0; e < emojis.length; e++) {
                    const emojiOrPath = emojis[e];
                    const isStar = (e === STAR_INDEX);
                    const isPatreon = (e === PATREON_INDEX);
                    const isImagePath = typeof emojiOrPath === 'string' && (emojiOrPath.endsWith('.png') || emojiOrPath.endsWith('.jpg') || emojiOrPath.endsWith('.svg')); // Basic check again
                    const sizeArr = [];

                    for (let s = 0; s < SIZE_LEVELS; s++) {
                        const size = MIN_SIZE + (s / (SIZE_LEVELS - 1)) * (MAX_SIZE - MIN_SIZE);
                        const hueArr = [];

                        // Create base canvas (size only, no blur)
                        const baseCanvas = document.createElement('canvas');
                        // Adjust canvas size based on whether it's an image or text emoji
                        // Images might need different base size calculations depending on aspect ratio
                        const baseSize = 2 * Math.ceil(size); // Keep this for now, might need adjustment for images
                        baseCanvas.width = baseCanvas.height = baseSize;
                        const baseCtx = baseCanvas.getContext('2d');

                        if (isImagePath) {
                            const img = loadedImages[e];
                            if (img) {
                                // Draw the loaded image centered onto the base canvas
                                // Maintain aspect ratio
                                const hRatio = baseCanvas.width / img.width;
                                const vRatio = baseCanvas.height / img.height;
                                const ratio = Math.min(hRatio, vRatio); // Use min ratio to fit within bounds
                                const drawWidth = img.width * ratio;
                                const drawHeight = img.height * ratio;
                                const drawX = (baseCanvas.width - drawWidth) / 2;
                                const drawY = (baseCanvas.height - drawHeight) / 2;
                                baseCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                            } else {
                                // Fallback or error handling if image didn't load
                                baseCtx.fillStyle = 'red'; // Indicate error
                                baseCtx.fillRect(0, 0, baseSize, baseSize);
                            }
                        } else {
                            // Handle text emojis as before
                            baseCtx.font = `${size}px Arial`;
                            baseCtx.textAlign = 'center';
                            baseCtx.textBaseline = 'middle';
                             // Set color for Patreon logo (if it were text) - no longer needed here
                            // if (isPatreon) { baseCtx.fillStyle = PATREON_ORANGE; }
                            baseCtx.fillText(emojiOrPath, baseCanvas.width / 2, baseCanvas.height / 2);
                        }

                        // --- Hue Variation Generation ---
                        if (isPatreon) {
                            // Patreon Icon (Image): Only store the base version
                            hueArr.push(baseCanvas);
                        } else if (isStar) {
                            // Star: Only store the base version
                            hueArr.push(baseCanvas);
                        } else {
                            // Non-stars: Only store the base version
                            hueArr.push(baseCanvas);
                        }
                        // --- End Hue Variation Generation ---

                        sizeArr.push(hueArr);
                    }
                    cache.push(sizeArr);
                }
                console.timeEnd('makeEmojiVariantCache'); // End timing
                // Indicate cache is ready AFTER population is complete
                emojiVariantCache = cache;
                isCacheReady = true;
            }).catch(error => {
                 console.error("Error loading images for cache:", error);
                 // Handle image loading errors appropriately
                 isCacheReady = false; // Ensure cache is marked as not ready on error
            });
        }

        // Particle class
        class Particle {
            constructor() {
                this.x = 0;
                this.y = 0;
                this.vx = 0;
                this.vy = 0;
                this.sun = null;
                this.previousSun = null; // Store the previous target point
                this.sunChangeTime = null; // Timestamp of the last sun change
                this.emojiIndex = 0;
                this.size = 0;
                this.mass = 1; // Added: Mass property, default to 1
                this.scaleFactor = 1; // Add scale factor property
                this.hueRotation = 0; // For stars: specific hue rotation value
                this.hueLevel = 0; // For non-stars: index into cached hues
                this.isPatreonParticle = false; // Flag for the special particle
                this.trail = []; // Initialize trail array
                this.fadeStartAlpha = 1.0; // Alpha at the start of a time change fade
                this.twinkleSpeed = 0; // Speed of alpha variation for stars
                this.twinklePhase = 0; // Phase offset for alpha variation
                this.reset(true);
            }

            reset(initial = false) {
                // Spawn outside the screen on a circle
                const theta = Math.random() * 2 * Math.PI;
                this.x = centerX + spawnRadius * Math.cos(theta);
                this.y = centerY + spawnRadius * Math.sin(theta);

                // Assign a random target point as the "sun"
                if (targetPoints.length > 0) {
                    const randomIndex = Math.floor(Math.random() * targetPoints.length);
                    this.sun = targetPoints[randomIndex];
                } else {
                    this.sun = { x: centerX, y: centerY };
                }

                // Initial velocity calculation
                const dx = this.sun.x - this.x;
                const dy = this.sun.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                // Calculate the angle towards the sun
                const angleToSun = Math.atan2(dy, dx);

                // Add a random offset to the angle
                const randomOffset = (Math.random() * 2 - 1) * PARTICLE_INITIAL_ANGLE_OFFSET;
                const finalAngle = angleToSun + randomOffset;

                // Calculate total speed - Doubled range [20, 40)
                const speed = PARTICLE_SPEED_MIN + Math.random() * (40 - PARTICLE_SPEED_MIN); // Max speed in range doubled to 40

                // Set velocity based on the final angle and speed
                this.vx = Math.cos(finalAngle) * speed;
                this.vy = Math.sin(finalAngle) * speed;

                // --- Emoji, Size, Scale, Hue Assignment ---
                // Keep current emoji if it's the special Patreon particle
                if (!this.isPatreonParticle) { 
                    this.emojiIndex = weightedEmojiIndices[Math.floor(Math.random() * weightedEmojiIndices.length)];
                    // Assign random size only to non-Patreon particles
                    this.size = MIN_SIZE + Math.random() * (MAX_SIZE - MIN_SIZE);
                } else {
                    // Patreon particle always gets MAX_SIZE
                    this.size = MAX_SIZE;
                }

                // Calculate Mass based on size (before scaling)
                if (MAX_SIZE > MIN_SIZE) {
                    const sizeRatio = (this.size - MIN_SIZE) / (MAX_SIZE - MIN_SIZE);
                    this.mass = PARTICLE_MIN_MASS + sizeRatio * (PARTICLE_MAX_MASS - PARTICLE_MIN_MASS);
                } else {
                    this.mass = (PARTICLE_MIN_MASS + PARTICLE_MAX_MASS) / 2; // Average mass if min=max size
                }
                // Ensure mass doesn't go outside bounds due to float issues
                this.mass = Math.max(PARTICLE_MIN_MASS, Math.min(PARTICLE_MAX_MASS, this.mass));

                // Set scale factor based on emoji
                if (this.isPatreonParticle) {
                    this.scaleFactor = PATREON_SCALE_FACTOR;
                } else if (this.emojiIndex === STAR_INDEX) {
                    this.scaleFactor = STAR_PARTICLE_SCALE_FACTOR;
                    // Initialize twinkle properties for stars
                    this.twinkleSpeed = (Math.random() * 0.01) + 0.005; // Increased speed (was 0.001, 0.0005)
                    this.twinklePhase = Math.random() * Math.PI * 2; // Random phase
                } else if (this.emojiIndex === MOON_INDEX) {
                    this.scaleFactor = MOON_PARTICLE_SCALE_FACTOR;
                } else {
                    this.scaleFactor = PLANET_PARTICLE_SCALE_FACTOR; // Use specific planet scale
                }

                // Set hue level
                if (this.isPatreonParticle) {
                     this.hueLevel = 0; // Patreon always uses base hue (orange)
                } else if (this.emojiIndex === STAR_INDEX) {
                    // Stars: Choose a random pre-rendered star hue level
                    this.hueLevel = Math.floor(Math.random() * STAR_HUE_LEVELS);
                } else {
                    // Non-stars: Calculate index for pre-rendered hue cache
                    this.hueLevel = Math.floor(Math.random() * HUE_LEVELS);
                }
                // --- End Emoji Assignment ---

                this.previousSun = null; // Reset previous sun on particle reset
                this.sunChangeTime = null; // Reset timestamp on particle reset
                this.fadeStartAlpha = 1.0; // Reset fade alpha
            }

            // Helper function to calculate alpha based on distance to a given point
            calculateAlphaForSun(sunPoint, maxAlphaValue) {
                if (!sunPoint) return MIN_ALPHA; // Handle cases where sunPoint might be null

                const maxR = spawnRadius;
                const dx = this.x - sunPoint.x;
                const dy = this.y - sunPoint.y;
                const r = Math.sqrt(dx * dx + dy * dy);
                const norm = Math.max(0, Math.min(1, r / maxR));

                let alpha;
                if (norm > ALPHA_FADE_RADIUS) {
                    alpha = MIN_ALPHA;
                } else {
                    const fadeNorm = 1 - (norm / ALPHA_FADE_RADIUS);
                    alpha = MIN_ALPHA + fadeNorm * (maxAlphaValue - MIN_ALPHA);
                }
                return alpha;
            }

            update(deltaTime) {
                // Skip gravity if fading out for time change
                if (!isFadingOutForTimeChange && gravityEnabled) {
                    const dx = this.sun.x - this.x;
                    const dy = this.sun.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    const minDistSq = PARTICLE_MIN_DIST * PARTICLE_MIN_DIST;

                    // Avoid division by zero or tiny distances, and use cached min distance squared
                    if (distSq > 1e-6) { 
                        const actualDistSq = Math.max(distSq, minDistSq);
                        const dist = Math.sqrt(actualDistSq); // Need sqrt for force calculation direction
                        // Apply mass to gravity force
                        const forceMagnitude = (PARTICLE_GRAVITY * this.mass) / actualDistSq;
                        // Apply force scaled by deltaTime
                        const forceScale = forceMagnitude * deltaTime / dist; // Pre-calculate scaling factor
                        this.vx += dx * forceScale;
                        this.vy += dy * forceScale;
                    }
                }

                // Apply velocity damping
                this.vx *= currentDampingFactor;
                this.vy *= currentDampingFactor;

                // --- Start: Enforce Minimum Speed ---
                const currentSpeedSq = this.vx * this.vx + this.vy * this.vy;
                const minSpeedSq = PARTICLE_MIN_ABS_SPEED * PARTICLE_MIN_ABS_SPEED;

                if (currentSpeedSq > 1e-6 && currentSpeedSq < minSpeedSq) { // Check if speed is below min but not zero
                    const currentSpeed = Math.sqrt(currentSpeedSq);
                    const scaleFactor = PARTICLE_MIN_ABS_SPEED / currentSpeed;
                    this.vx *= scaleFactor;
                    this.vy *= scaleFactor;
                }
                // --- End: Enforce Minimum Speed ---

                // Clamp velocity to maximum (using squared comparison)
                const maxVel = PARTICLE_MAX_VEL;
                const maxVelSq = maxVel * maxVel;
                const velSq = this.vx * this.vx + this.vy * this.vy; // Recalculate velSq after potential min speed boost
                if (velSq > maxVelSq) {
                    const vel = Math.sqrt(velSq); // Need sqrt only here for normalization
                    const clampFactor = maxVel / vel;
                    this.vx *= clampFactor;
                    this.vy *= clampFactor;
                }

                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;

                // Add current position to trail if it's the Patreon particle
                if (this.isPatreonParticle) {
                    this.trail.push({ x: this.x, y: this.y });
                    // Keep trail at the defined length
                    if (this.trail.length > PATREON_TRAIL_LENGTH) {
                        this.trail.shift(); // Remove the oldest point
                    }
                }

                // Reset if far off screen
                if (
                    this.x < -PARTICLE_OUT_BOUNDS || this.x > canvas.width + PARTICLE_OUT_BOUNDS ||
                    this.y < -PARTICLE_OUT_BOUNDS || this.y > canvas.height + PARTICLE_OUT_BOUNDS
                ) {
                    this.reset();
                }

                // Apply mouse interaction
                if (mouseX !== -1 && mouseY !== -1) {
                    const dx = this.x - mouseX;
                    const dy = this.y - mouseY;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < MOUSE_INTERACTION_RADIUS * MOUSE_INTERACTION_RADIUS && distSq > 1e-4) { // Added check for distSq > 1e-4
                        const dist = Math.sqrt(distSq);
                        
                        if (this.isPatreonParticle) {
                            // Attract Patreon particle TOWARDS the mouse
                            // Force proportional to distance (gentler pull when close)
                            const attractForce = MOUSE_ATTRACT_STRENGTH * dist; 
                            const forceScale = attractForce * deltaTime / dist; // Normalize direction vector
                            // Attract Patreon particle TOWARDS the mouse (subtract force component)
                            this.vx -= dx * forceScale;
                            this.vy -= dy * forceScale;
                        } else {
                            // Repel other particles AWAY from the mouse
                            // Force proportional to 1/distSq
                            const repelForce = MOUSE_REPEL_STRENGTH / (distSq); 
                            const forceScale = repelForce * deltaTime / dist; // Normalize direction vector
                            // Repel other particles AWAY from the mouse (add force component)
                            this.vx += dx * forceScale;
                            this.vy += dy * forceScale;
                        }
                    }
                }
            }

            draw() {
                // Don't draw if cache isn't ready
                if (!isCacheReady) return;

                const maxR = spawnRadius; // Keep maxR needed for helpers
                let sizeLevel = 0; // Initialize sizeLevel
                if (MAX_SIZE > MIN_SIZE) { // Prevent division by zero
                  sizeLevel = Math.round(((this.size - MIN_SIZE) / (MAX_SIZE - MIN_SIZE)) * (SIZE_LEVELS - 1));
                } // If MIN_SIZE === MAX_SIZE, sizeLevel remains 0, which is safe.
                
                // Clamp sizeLevel to ensure it's within bounds [0, SIZE_LEVELS - 1]
                sizeLevel = Math.max(0, Math.min(SIZE_LEVELS - 1, sizeLevel));

                // Determine the correct max alpha based on particle type
                const maxAlphaToUse = this.isPatreonParticle ? PATREON_MAX_ALPHA : MAX_ALPHA;

                // --- Alpha Calculation --- START
                let finalAlpha;
                if (isFadingOutForTimeChange) {
                    // Calculate alpha during the time change fade out
                    const elapsedFadeTime = Date.now() - fadeOutStartTime;
                    const fadeProgress = Math.min(1, elapsedFadeTime / TIME_CHANGE_FADE_DURATION);
                    finalAlpha = Math.max(0, this.fadeStartAlpha * (1 - fadeProgress));
                } else {
                    // Normal alpha calculation based on distance to current sun
                    finalAlpha = this.calculateAlphaForSun(this.sun, maxAlphaToUse);
                    // The old transition logic based on previousSun is removed
                }

                // Apply twinkle effect to stars
                if (!this.isPatreonParticle && this.emojiIndex === STAR_INDEX && this.twinkleSpeed > 0) {
                     // Calculate twinkle multiplier (oscillates between 0 and 1)
                     const twinkleMultiplier = 0.5 * (1 + Math.sin(Date.now() * this.twinkleSpeed + this.twinklePhase));
                     // Adjust alpha based on twinkle amount (ensures alpha doesn't go below (1 - amount) * base)
                     const minAlphaFactor = 1.0 - STAR_TWINKLE_AMOUNT;
                     finalAlpha *= (minAlphaFactor + STAR_TWINKLE_AMOUNT * twinkleMultiplier);
                }
                 // --- Alpha Calculation --- END

                // Ensure indices are valid integers before accessing cache
                const validEmojiIndex = Math.max(0, Math.min(emojis.length - 1, Math.floor(this.emojiIndex)));
                const validHueLevel = Math.max(0, Math.min(HUE_LEVELS - 1, Math.floor(this.hueLevel)));

                const emojiCanvas = emojiVariantCache[validEmojiIndex]?.[sizeLevel]?.[validHueLevel];

                ctx.save();
                // Draw the trail *first* if it's the Patreon particle
                if (this.isPatreonParticle && this.trail.length > 1) {
                    const baseEmojiCanvas = emojiVariantCache[validEmojiIndex]?.[sizeLevel]?.[validHueLevel];

                    if (baseEmojiCanvas) { // Only draw trail if we have the canvas
                        const baseWidth = baseEmojiCanvas.width;
                        const baseHeight = baseEmojiCanvas.height;
                        const trailLength = this.trail.length;

                        for (let i = 0; i < trailLength - 1; i += 4) {
                            const point = this.trail[i];
                            const trailProgress = i / (trailLength - 1);
                            const trailAlpha = finalAlpha * Math.pow(trailProgress, 3.0) * 1.0;
                            const trailScale = 0.5 + trailProgress * 0.5;
                            const trailWidth = baseWidth * this.scaleFactor * trailScale;
                            const trailHeight = baseHeight * this.scaleFactor * trailScale;
                            const trailX = point.x - trailWidth / 2;
                            const trailY = point.y - trailHeight / 2;

                            if (trailWidth < 1 || trailHeight < 1 || trailAlpha <= 0.01) continue;
                            const hue = (Date.now() / 15 + i * (360 / trailLength)) % 360;
                            const currentGlobalAlpha = ctx.globalAlpha;
                            ctx.globalAlpha = Math.max(0, Math.min(1, trailAlpha));
                            ctx.save();
                            ctx.filter = `hue-rotate(${hue}deg) saturate(300%) brightness(150%)`;
                            ctx.drawImage(baseEmojiCanvas, trailX, trailY, trailWidth, trailHeight);
                            ctx.restore();
                            ctx.globalAlpha = currentGlobalAlpha;
                        }
                    }
                }

                // Now, draw the main particle image
                if (emojiCanvas) {
                    ctx.save();
                    if (this.isPatreonParticle) {
                        const glowHue = (Date.now() / 20) % 360;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = `hsla(${glowHue}, 100%, 70%, 0.8)`;
                    }

                    // Apply the calculated finalAlpha
                    ctx.globalAlpha = Math.max(0, Math.min(1, finalAlpha)); // Ensure alpha is valid

                    const destWidth = emojiCanvas.width * this.scaleFactor;
                    const destHeight = emojiCanvas.height * this.scaleFactor;
                    const destX = this.x - destWidth / 2;
                    const destY = this.y - destHeight / 2;
                    ctx.drawImage(emojiCanvas, destX, destY, destWidth, destHeight);
                    ctx.restore();
                } else {
                    console.error("Failed to get emojiCanvas for:", { emojiIndex: this.emojiIndex, sizeLevel: sizeLevel });
                }

                ctx.restore(); // Restore the initial saved state
            }
        }

        // Function to get current local time in user's timezone
        function getCurrentLocalTime() {
            const now = new Date();
            // Format as 12-hour time with AM/PM in user's local timezone
            let hours = now.getHours();
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12; // Convert 0 to 12 for midnight
            return `${hours}:${minutes}`;
        }

        // Responsive font size based on canvas width
        function getResponsiveFontSize() {
            // You can tweak the multiplier for your preferred size
            return Math.max(RESPONSIVE_FONT_MIN, Math.min(canvas.width, canvas.height) * RESPONSIVE_FONT_MULTIPLIER);
        }

        // Define time string and compute target shape
        function computeTargetPoints() {
            // Create offscreen canvas
            const offscreenCanvas = document.createElement('canvas');
            const fontSize = getResponsiveFontSize();
            offscreenCanvas.width = canvas.width;
            offscreenCanvas.height = canvas.height;
            const offscreenCtx = offscreenCanvas.getContext('2d');

            // Get current local time
            const timeString = getCurrentLocalTime();

            // Common text settings
            offscreenCtx.font = `${fontSize}px Arial, sans-serif`;
            offscreenCtx.textAlign = 'center';
            offscreenCtx.textBaseline = 'middle';
            offscreenCtx.fillStyle = 'white'; // Target points are based on white pixels

            const isMobile = canvas.width < MOBILE_WIDTH_THRESHOLD;

            if (isMobile) {
                // --- Vertical Rendering for Mobile (Hours over Minutes) ---
                const [hourString, minuteString] = timeString.split(':');
                const verticalSpacing = fontSize * 0.1; // Reduced spacing (was 0.25)

                // Center text horizontally
                const textX = canvas.width / 2;

                // Calculate Y coordinates directly relative to the canvas center
                const hourY = canvas.height / 2 - fontSize / 2 - verticalSpacing / 2;
                const minuteY = canvas.height / 2 + fontSize / 2 + verticalSpacing / 2;

                // Draw Hour String (Top line) - using calculated center Y
                offscreenCtx.fillText(hourString, textX, hourY);

                // Draw Minute String (Bottom line) - using calculated center Y
                offscreenCtx.fillText(minuteString, textX, minuteY);
                // --- End Vertical Rendering ---
            } else {
                // --- Horizontal Rendering (Existing Logic) ---
                const textX = canvas.width / 2;
                const textY = canvas.height / 2;
                offscreenCtx.fillText(timeString, textX, textY);
                // --- End Horizontal Rendering ---
            }

            // Get pixel data
            const imageData = offscreenCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            targetPoints = [];

            // Sample pixels, but only keep points that are not too close to existing ones
            for (let y = 0; y < canvas.height; y += TARGET_POINT_STEP) {
                for (let x = 0; x < canvas.width; x += TARGET_POINT_STEP) {
                    const index = (y * canvas.width + x) * 4;
                    const alpha = data[index + 3];
                    if (alpha > TARGET_POINT_ALPHA_THRESHOLD) {
                        // Only add this point if it's not too close to any existing point
                        let tooClose = false;
                        for (let i = 0; i < targetPoints.length; i++) {
                            const dx = x - targetPoints[i].x;
                            const dy = y - targetPoints[i].y;
                            if (dx * dx + dy * dy < TARGET_POINT_MIN_DIST * TARGET_POINT_MIN_DIST) {
                                tooClose = true;
                                break;
                            }
                        }
                        if (!tooClose) {
                            targetPoints.push({ x, y });
                        }
                    }
                }
            }
        }

        // Draw target points for debugging
        function drawTargetPoints() {
            ctx.save();
            ctx.fillStyle = 'white';
            targetPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 1, 0, 2 * Math.PI);
                ctx.fill();
            });
            ctx.restore();
        }

        // Draw toggle hint with emojis
        function drawHint() {
            ctx.save();
            ctx.font = UI_FONT_STYLE;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`Press T to toggle target gravity ${gravityEnabled ? '✅' : '❌'}`, HINT_X, HINT_Y1);

            // Display memory usage if available
            if (performance && performance.memory) {
                const usedHeapMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                // Optionally display limit: const limitHeapMB = (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(1);
                ctx.fillText(`Mem: ${usedHeapMB} MB`, HINT_X, HINT_Y2); // Use HINT_Y2 for the second line
            } else {
                ctx.fillText('Mem: N/A', HINT_X, HINT_Y2); // Indicate if memory API is not supported
            }

            ctx.restore();
        }

        // Toggle gravity on key press with visual feedback
        document.addEventListener('keydown', (event) => {
            switch (event.key.toLowerCase()) {
                case 't':
                    gravityEnabled = !gravityEnabled;
                    break;
                case 'h':
                    hideUI = !hideUI;
                    break;
            }
        });

        // Update target points every minute change to reflect current time
        function scheduleNextTargetPointsUpdate() {
            const now = Date.now();
            const date = new Date(now);
            const msToNextMinute = (60 - date.getSeconds()) * 1000 - date.getMilliseconds();

            // Use a slightly shorter timeout to ensure we trigger *before* the exact minute change
            // to capture particle state accurately.
            const timeoutDuration = Math.max(10, msToNextMinute - 50); // Ensure timeout is not negative

            setTimeout(() => {
                // --- Check for hour change and regenerate cache if needed --- START
                const currentHour = new Date().getHours(); // Get hour *just before* minute change
                if (currentHour !== currentHourForCache) {
                    currentHourForCache = currentHour;
                    currentTimeHueShift = getTimeBasedHueShift(); // This function now just returns 0
                    console.log(`Hour changed to ${currentHour}. Regenerating cache.`);
                    makeEmojiVariantCache(); // Regenerate cache
                }
                // --- Check for hour change and regenerate cache if needed --- END

                // --- Initiate Time Change Fade Out --- START
                isFadingOutForTimeChange = true;
                fadeOutStartTime = Date.now(); // Record exact start time
                console.log("Initiating time change fade out...");

                // Store current alpha for each particle before fade
                particles.forEach(p => {
                    const maxAlphaToUse = p.isPatreonParticle ? PATREON_MAX_ALPHA : MAX_ALPHA;
                    // Calculate alpha based on current position relative to its *current* sun
                    p.fadeStartAlpha = p.calculateAlphaForSun(p.sun, maxAlphaToUse);
                });

                // Schedule the function to run *after* the fade duration
                setTimeout(finishTimeChangeTransition, TIME_CHANGE_FADE_DURATION);
                 // --- Initiate Time Change Fade Out --- END

            }, timeoutDuration);
        }

        // Function called after the time change fade-out is complete
        function finishTimeChangeTransition() {
            console.log("Fade out complete. Resetting particles for new time.");

            // 1. Compute the new target points based on the *new* current time
            computeTargetPoints(); // This now reflects the minute that just started

            // 2. Reset all particles to spawn towards the new points
            particles.forEach(p => {
                 // Reset assigns a new random sun from the *updated* targetPoints
                 p.reset(false); 
            });
            // Special handling for Patreon particle if it exists and was spawned
            if (patreonParticleSpawned && patreonParticle) {
                // Ensure its sun is also updated correctly after reset
                 if (targetPoints.length > 0) {
                    const randomIndex = Math.floor(Math.random() * targetPoints.length);
                    patreonParticle.sun = targetPoints[randomIndex];
                 } else {
                    patreonParticle.sun = { x: centerX, y: centerY };
                 }
                 patreonParticle.previousSun = null; // Clear any transition state
                 patreonParticle.sunChangeTime = null;
            }

            // 3. Mark fade out as complete
            isFadingOutForTimeChange = false;

            // 4. Schedule the *next* time update check for the *following* minute
            scheduleNextTargetPointsUpdate();
        }

        // Initial call to start the cycle
        // scheduleNextTargetPointsUpdate(); // <<< Moved this call lower after initial setup

        // Animation loop
        let patreonParticle = null; // Reference to the special particle

        function animate(time) {
            if (!startTime) startTime = time;
            const elapsed = time - startTime;
            const deltaTime = (time - lastTime) / 1000 || 0; // Ensure deltaTime is not NaN on first frame
            lastTime = time;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- Update and Draw Stars ---
            ctx.save();
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                // Update position
                star.x += star.vx * deltaTime;
                star.y += star.vy * deltaTime;

                // Wrap around screen edges
                if (star.x < 0) star.x += canvas.width;
                else if (star.x > canvas.width) star.x -= canvas.width;
                if (star.y < 0) star.y += canvas.height;
                else if (star.y > canvas.height) star.y -= canvas.height;

                // Draw star (using fillRect for simplicity)
                ctx.fillRect(star.x - star.size / 2, star.y - star.size / 2, star.size, star.size);
            });
            ctx.restore();
            // --- End Stars ---

            const targetParticles = Math.min(Math.floor((elapsed / SPAWN_DURATION) * MAX_PARTICLES), MAX_PARTICLES);
            // Remove excess particles if MAX_PARTICLES decreased
            if (particles.length > MAX_PARTICLES) {
                particles.length = MAX_PARTICLES; // Simply truncate the array
                if (debugParticleIndex !== null && debugParticleIndex >= particles.length) {
                   debugParticleIndex = null; // Reset debug index if it's now out of bounds
                }
            }
            // Add new particles if needed
            while (particles.length < targetParticles && particles.length < MAX_PARTICLES) {
                particles.push(new Particle());
            }

            // --- Delayed Patreon Particle Configuration ---
            // Check if the Patreon particle hasn't been configured yet,
            // if the initial spawn phase time has passed OR max particles reached,
            // and if the specific delay time has passed.
            if (!patreonParticleSpawned && 
                (elapsed >= SPAWN_DURATION || particles.length === MAX_PARTICLES) &&
                elapsed >= PATREON_SPAWN_DELAY && 
                particles.length > PATREON_PARTICLE_INDEX) 
            {
                patreonParticle = particles[PATREON_PARTICLE_INDEX];
                if (patreonParticle) { // Ensure the particle actually exists
                    patreonParticle.isPatreonParticle = true;
                    patreonParticle.emojiIndex = PATREON_INDEX;
                    patreonParticle.size = MAX_SIZE; // Still use max base size, scale factor handles visual size
                    patreonParticle.scaleFactor = PATREON_SCALE_FACTOR; // Apply the reduced scale factor
                    patreonParticle.hueLevel = 0; // Base hue
                    // Reset trail to start fresh when it spawns
                    patreonParticle.trail = []; 

                    // --- Reset Position and Velocity to Spawn from Edge ---
                    const theta = Math.random() * 2 * Math.PI;
                    patreonParticle.x = centerX + spawnRadius * Math.cos(theta);
                    patreonParticle.y = centerY + spawnRadius * Math.sin(theta);

                    // Assign a random target point as the "sun"
                    if (targetPoints.length > 0) {
                        const randomIndex = Math.floor(Math.random() * targetPoints.length);
                        patreonParticle.sun = targetPoints[randomIndex];
                    } else {
                        patreonParticle.sun = { x: centerX, y: centerY };
                    }
                    patreonParticle.previousSun = null; // Ensure no lingering transition alpha
                    patreonParticle.sunChangeTime = null;

                    // Initial velocity calculation (same logic as reset)
                    const dx = patreonParticle.sun.x - patreonParticle.x;
                    const dy = patreonParticle.sun.y - patreonParticle.y;
                    const angleToSun = Math.atan2(dy, dx);
                    const randomOffset = (Math.random() * 2 - 1) * PARTICLE_INITIAL_ANGLE_OFFSET;
                    const finalAngle = angleToSun + randomOffset;
                    const speed = PARTICLE_SPEED_MIN + Math.random() * (40 - PARTICLE_SPEED_MIN);
                    patreonParticle.vx = Math.cos(finalAngle) * speed;
                    patreonParticle.vy = Math.sin(finalAngle) * speed;
                    // --- End Reset Position and Velocity ---

                    patreonParticleSpawned = true; // Mark as spawned
                    console.log(`Patreon particle configured and spawned at ${elapsed.toFixed(0)}ms`);
                }
            }
            // --- End Delayed Configuration ---

            // Update all particles first (gravity, damping, velocity limits)
            particles.forEach(p => p.update(deltaTime));

            // --- Start Particle-Particle Collision Handling ---
            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                for (let j = i + 1; j < particles.length; j++) {
                    const p2 = particles[j];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distSq = dx * dx + dy * dy;

                    // Estimate radius based on base size and scale factor
                    // Using base size directly as radius proxy, adjust factor if needed
                    const radius1 = (p1.size * p1.scaleFactor) * 0.5; 
                    const radius2 = (p2.size * p2.scaleFactor) * 0.5; 
                    const collisionDist = (radius1 + radius2) * COLLISION_DISTANCE_FACTOR;
                    const collisionDistSq = collisionDist * collisionDist;

                    if (distSq < collisionDistSq && distSq > 1e-6) {
                        const dist = Math.sqrt(distSq);
                        const overlap = collisionDist - dist; // How much they overlap based on the threshold

                        // Calculate force magnitude - proportional to overlap, stronger when closer
                        // Avoid extremely large forces at very small distances
                        const forceMagnitude = COLLISION_REPEL_STRENGTH * overlap / dist;

                        // Calculate force vector components
                        const forceX = (dx / dist) * forceMagnitude;
                        const forceY = (dy / dist) * forceMagnitude;

                        // Apply force scaled by deltaTime and distributed by inverse mass
                        const totalMass = p1.mass + p2.mass;
                        if (totalMass > 1e-6) { // Avoid division by zero if masses are somehow zero
                             // Apply velocity change directly (force * dt / mass)
                             const accelScale = deltaTime / totalMass;
                             p1.vx -= forceX * p2.mass * accelScale;
                             p1.vy -= forceY * p2.mass * accelScale;
                             p2.vx += forceX * p1.mass * accelScale;
                             p2.vy += forceY * p1.mass * accelScale;
                        }
                    }
                }
            }
            // --- End Particle-Particle Collision Handling ---

            // Draw non-Patreon particles with potential hue shift
            particles.forEach((p, index) => {
                if (index !== PATREON_PARTICLE_INDEX) {
                    p.draw();
                }
            });

            // Draw Patreon particle last (if it exists) without the time-based shift
            if (patreonParticleSpawned && patreonParticle) { // Check spawn flag before drawing
                patreonParticle.draw();
            }

            // Draw debugging elements and UI only if not hidden
            if (!hideUI) {
                drawTargetPoints();
                drawHint();

                // After particles are spawned:
                if (particles.length > 0) {
                    // If no debug particle, or if it was reset (replaced), pick a new one
                    if (
                        debugParticleIndex === null ||
                        debugParticleIndex >= particles.length
                    ) {
                        debugParticleIndex = Math.floor(Math.random() * particles.length);
                    }
                    const p = particles[debugParticleIndex];
                    ctx.save();
                    ctx.strokeStyle = DEBUG_LINE_COLOR;
                    ctx.lineWidth = DEBUG_LINE_WIDTH;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.sun.x, p.sun.y);
                    ctx.stroke();
                    ctx.restore();

                    // If the particle is out of bounds (about to be reset), pick a new one next frame
                    if (
                        p.x < -PARTICLE_OUT_BOUNDS || p.x > canvas.width + PARTICLE_OUT_BOUNDS ||
                        p.y < -PARTICLE_OUT_BOUNDS || p.y > canvas.height + PARTICLE_OUT_BOUNDS
                    ) {
                        debugParticleIndex = null;
                    }
                }

                // Draw notifications
                notifications = notifications.filter(n => !n.isExpired());
                notifications.forEach((n, index) => n.draw(index));
            }

            requestAnimationFrame(animate);
        }

        // Initialize target points and start animation
        // First, determine initial hue shift before generating cache
        currentHourForCache = new Date().getHours();
        currentTimeHueShift = getTimeBasedHueShift();
        resizeCanvas(); // Now calls makeEmojiVariantCache with the initial shift
        window.addEventListener('resize', resizeCanvas);
        computeTargetPoints(); // computeTargetPoints is also called inside resizeCanvas, maybe remove one? Let's keep it for now.
        scheduleNextTargetPointsUpdate(); // Schedule the hourly check/update
        requestAnimationFrame(animate);

        // Function to generate stars
        function createStars() {
            stars.length = 0; // Clear existing stars
            for (let i = 0; i < NUM_STARS; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const speed = STAR_MIN_SPEED + Math.random() * (STAR_MAX_SPEED - STAR_MIN_SPEED);
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: STAR_MIN_SIZE + Math.random() * (STAR_MAX_SIZE - STAR_MIN_SIZE),
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed
                });
            }
        }

        // Function to update background color based on time
        function updateBackgroundColor() {
            const hour = new Date().getHours();
            let bgColor;

            // Define dark color palette based on time of day
            if (hour >= 22 || hour < 5) { // Late Night / Early Morning
                bgColor = '#030310'; // Very dark blue/purple
            } else if (hour >= 5 && hour < 7) { // Dawn
                bgColor = '#080818'; // Slightly lighter dark blue
            } else if (hour >= 7 && hour < 18) { // Daytime
                bgColor = '#101020'; // Dark greyish-blue
            } else if (hour >= 18 && hour < 20) { // Dusk
                bgColor = '#080515'; // Darkening blue/purple
            } else { // Evening (20 - 22)
                bgColor = '#050312'; // Darker purple/blue
            }

            document.body.style.backgroundColor = bgColor;
        }

        // Function to calculate hue shift based on time of day (Now simplified)
        function getTimeBasedHueShift() {
            // No longer applies time-based shifts, just returns 0
            // The cache generation will create full spectrum variations.
            return 0;
        }

        // Initial setup calls
        updateBackgroundColor(); // Set initial background color
        setInterval(updateBackgroundColor, 60000); // Update background every minute

        // --- Helper function to check if a point is inside the Patreon particle ---
        function isPointInsidePatreonParticle(checkX, checkY) {
            if (!patreonParticleSpawned || !patreonParticle) {
                return false; // Not spawned or doesn't exist
            }

            const p = patreonParticle;
            let particleWidth = 0;
            let particleHeight = 0;

            // Estimate size (reuse logic from click handler - consider refactoring)
            if (emojiVariantCache && emojiVariantCache[p.emojiIndex] && emojiVariantCache[p.emojiIndex][SIZE_LEVELS-1]) {
                const approxLargestHueCanvas = emojiVariantCache[p.emojiIndex][SIZE_LEVELS-1][0];
                if (approxLargestHueCanvas) {
                    particleWidth = approxLargestHueCanvas.width * p.scaleFactor;
                    particleHeight = approxLargestHueCanvas.height * p.scaleFactor;
                }
            }
            if (particleWidth === 0) { // Fallback
                particleWidth = (2 * MAX_SIZE) * p.scaleFactor;
                particleHeight = (2 * MAX_SIZE) * p.scaleFactor;
            }

            // Add padding to the hitbox dimensions
            const paddedWidth = particleWidth + 2 * PATREON_HITBOX_PADDING;
            const paddedHeight = particleHeight + 2 * PATREON_HITBOX_PADDING;

            const particleLeft = p.x - paddedWidth / 2;
            const particleTop = p.y - paddedHeight / 2;

            return (
                checkX >= particleLeft &&
                checkX <= particleLeft + paddedWidth &&
                checkY >= particleTop &&
                checkY <= particleTop + paddedHeight
            );
        }
        // --- End Helper Function ---

        // Click Handler for Patreon Link
        function handleCanvasClick(event) {
            if (!patreonParticle) return; // No particle to check

            const rect = canvas.getBoundingClientRect();
             // Adjust click coordinates based on canvas scaling/position if needed
             // For this setup (fixed canvas covering viewport), direct coordinates might work
             // Consider canvas CSS transform if applied
            const scaleX = canvas.width / rect.width;    // relationship bitmap vs. element for X
            const scaleY = canvas.height / rect.height;  // relationship bitmap vs. element for Y

            const clickX = (event.clientX - rect.left) * scaleX;   // scale mouse coordinates after they have
            const clickY = (event.clientY - rect.top) * scaleY;    // been adjusted to be relative to element

            // Check if click is within bounds using the helper function
            if (patreonParticleSpawned && isPointInsidePatreonParticle(clickX, clickY)) {
                window.open(PATREON_URL, '_blank');
            }
        }

        // Add click listener
        canvas.addEventListener('click', handleCanvasClick);

        // Mouse Move Listener for Hover Effect
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (event.clientX - rect.left) * scaleX;
            mouseY = (event.clientY - rect.top) * scaleY;

            let nowHovering = false;
            if (patreonParticleSpawned && patreonParticle) { // Check spawn flag
                 // Check hover using the helper function
                 nowHovering = isPointInsidePatreonParticle(mouseX, mouseY);
            }

            // Update cursor only if hover state changed
            if (nowHovering !== isHoveringPatreon) {
                canvas.style.cursor = nowHovering ? 'pointer' : 'default';
                isHoveringPatreon = nowHovering;
            }
        });

        // Mouse Leave Listener to reset cursor
        canvas.addEventListener('mouseleave', () => {
            if (patreonParticleSpawned && isHoveringPatreon) { // Check spawn flag
                canvas.style.cursor = 'default';
                isHoveringPatreon = false;
                mouseX = -1; // Reset mouse coords
                mouseY = -1;
            }
        });

        // --- Add Touch Event Listeners ---
        function updateMousePosFromEvent(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                // Use the first touch point
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.clientX !== undefined) {
                // Use mouse coordinates if available (for mousemove)
                clientX = event.clientX;
                clientY = event.clientY;
            } else {
                // If no coordinates found, reset
                mouseX = -1;
                mouseY = -1;
                return;
            }

            mouseX = (clientX - rect.left) * scaleX;
            mouseY = (clientY - rect.top) * scaleY;
        }

        canvas.addEventListener('touchstart', (event) => {
            event.preventDefault(); // Prevent default touch behavior like scrolling
            updateMousePosFromEvent(event);
        }, { passive: false });

        canvas.addEventListener('touchmove', (event) => {
            event.preventDefault(); // Prevent default touch behavior
            updateMousePosFromEvent(event);
        }, { passive: false });

        canvas.addEventListener('touchend', (event) => {
            // Check if the touch end location is inside the Patreon particle
            if (patreonParticleSpawned && event.changedTouches && event.changedTouches.length > 0) {
                const touch = event.changedTouches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const touchEndX = (touch.clientX - rect.left) * scaleX;
                const touchEndY = (touch.clientY - rect.top) * scaleY;

                if (isPointInsidePatreonParticle(touchEndX, touchEndY)) {
                    window.open(PATREON_URL, '_blank');
                     // Optional: Prevent the default behavior if the link was opened
                     // to avoid potential unwanted side effects like scrolling.
                     // event.preventDefault(); // Let's leave this commented out for now unless needed
                }
            }

            // Reset mouse position when touch ends
            mouseX = -1;
            mouseY = -1;
            // Also reset hover state if touch ends
            if (isHoveringPatreon) {
                 canvas.style.cursor = 'default';
                 isHoveringPatreon = false;
            }
        });

        canvas.addEventListener('touchcancel', (event) => {
             // Handle cancelled touches similarly to touchend
             mouseX = -1;
             mouseY = -1;
             if (isHoveringPatreon) {
                 canvas.style.cursor = 'default';
                 isHoveringPatreon = false;
             }
        });
        // --- End Touch Event Listeners ---

    </script>
</body>
</html>