<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home of Cheezos</title>
    <link rel="icon" href="public/images/icon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            /* background: #050505; */ /* Removed: Will be set dynamically */
            overflow: hidden;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="vortex"></canvas>
    <script type="text/javascript">
        // === CONFIGURABLE CONSTANTS ===
        const CANVAS_SIZE_MULTIPLIER = 1.2;
        const SPAWN_RADIUS_EXTRA = 50;
        const SPAWN_DURATION = 3000;
        const SIZE_LEVELS = 10;
        const HUE_LEVELS = 6; // Reduced from 12
        const STAR_HUE_LEVELS = 3; // Reduced from 5
        const MAX_BLUR = 0;
        const MIN_BLUR = 0;
        const MIN_ALPHA = 0.0;
        const MAX_ALPHA = 0.8;
        const ALPHA_FADE_RADIUS = 0.2;
        const STAR_WEIGHT = 100;
        const OTHER_EMOJI_WEIGHT = 1;
        const PARTICLE_SPEED_MIN = 20;
        const PARTICLE_PERP_SPEED = 5;
        const PARTICLE_INITIAL_ANGLE_OFFSET = Math.PI / 8; // Increased from PI / 12 (15deg -> 22.5deg)
        const PARTICLE_MIN_DIST = 120;
        const PARTICLE_GRAVITY = 80000000;
        const PARTICLE_MAX_VEL = 250;
        const PARTICLE_DAMPING_FACTOR = 0.998; // Reduced damping from 0.99
        const PARTICLE_MIN_ABS_SPEED = 5; // Increased minimum speed from 1.5
        const PARTICLE_OUT_BOUNDS = 200;
        const NOTIFICATION_DURATION = 2000;
        const UI_FONT_STYLE = '16px Arial, sans-serif';
        const HINT_X = 10;
        const HINT_Y1 = 10;
        const HINT_Y2 = 30;
        const TARGET_POINT_STEP = 4;
        const TARGET_POINT_MIN_DIST = 5;
        const TARGET_POINT_ALPHA_THRESHOLD = 128;
        const NOTIFICATION_STACK_Y = 50;
        const NOTIFICATION_STACK_STEP = 20;
        const DEBUG_LINE_COLOR = 'lime';
        const DEBUG_LINE_WIDTH = 2;
        const RESPONSIVE_FONT_MIN = 24;
        const RESPONSIVE_FONT_MULTIPLIER = 0.5;
        const SCHEDULE_UPDATE_BUFFER = 50;
        const ALPHA_TRANSITION_DURATION = 1500; // Duration for alpha transition in ms (e.g., 1.5 seconds)

        // Starfield constants
        const NUM_STARS = 300;
        const STAR_MIN_SIZE = 0.5;
        const STAR_MAX_SIZE = 2;
        const STAR_MIN_SPEED = 1;
        const STAR_MAX_SPEED = 4;

        // Particle specific constants
        const STAR_PARTICLE_SCALE_FACTOR = 0.4; // Stars will be 60% of the normal size

        // Patreon Link Integration
        const PATREON_URL = 'https://www.patreon.com/c/cheezos/'; // <<< --- UPDATED URL
        const PATREON_ORANGE = '#FF424D';
        const PATREON_PARTICLE_INDEX = 0; // Particle at index 0 will be the Patreon link
        const PATREON_SCALE_FACTOR = 1.125; // Reduced size by 25% (was 1.5)
        const PATREON_MAX_ALPHA = 1.0; // Patreon particle max alpha
        const PATREON_TRAIL_LENGTH = 30; // Number of points in the trail (Increased again)
        const PATREON_SPAWN_DELAY = 10000; // 10-second spawn delay in milliseconds

        // Mouse interaction constants
        const MOUSE_INTERACTION_RADIUS = 50; // How close the pointer needs to be
        const MOUSE_REPEL_STRENGTH = 10000000; // How strongly other particles are pushed
        const MOUSE_ATTRACT_STRENGTH = 50; // How strongly the Patreon particle is pulled (Lower value for gentler pull)

        // === END CONFIGURABLE CONSTANTS ===

        // Global variables that will be calculated dynamically
        let MAX_PARTICLES;
        let MIN_SIZE;
        let MAX_SIZE;
        let emojiVariantCache;
        let isCacheReady = false;
        let currentHourForCache = -1; // Track hour used for cache generation
        let currentTimeHueShift = 0; // Store the current hue shift value

        // Space/planet-themed emojis (all planets + Pluto + Sun + Moon + Star)
        const emojis = [
            '☀️', // Sun
            '🌕', // Full Moon
            '🌍', // Earth
            '🌎', // Earth Americas
            '🌏', // Earth Asia-Australia
            '🪐', // Saturn
            '⭐', // Star
            '🪐', // Uranus/Neptune (reusing Saturn for outer planets)
            '🌕', // Mercury (reusing full moon)
            '🪐', // Jupiter (reusing Saturn)
            'public/images/icon.png'  // Patreon Logo Path
        ];
        const STAR_INDEX = emojis.indexOf('⭐');
        const PATREON_INDEX = emojis.indexOf('public/images/icon.png');

        const emojiWeights = emojis.map((e, i) => {
            if (i === PATREON_INDEX) return 0; // Patreon particle is not randomly selected
            if (i === STAR_INDEX) return STAR_WEIGHT;
            return OTHER_EMOJI_WEIGHT;
        });
        const weightedEmojiIndices = []; // Used for non-Patreon particles
        for (let i = 0; i < emojis.length; i++) {
            // Only add non-Patreon emojis based on weight
            if (i !== PATREON_INDEX) { 
                for (let w = 0; w < emojiWeights[i]; w++) {
                    weightedEmojiIndices.push(i);
                }
            }
        }
    </script>
    <script>
        const canvas = document.getElementById('vortex');
        const ctx = canvas.getContext('2d');

        // Declare global state variables
        let targetPoints = [];
        let gravityEnabled = true; // Target points gravity enabled by default
        let notifications = [];
        let hideUI = true;
        let centerX, centerY, spawnRadius;
        let startTime = null;
        let lastTime = 0;
        let debugParticleIndex = null;
        const particles = [];
        const stars = []; // Array to hold star data
        let patreonParticleSpawned = false; // Flag to track if Patreon particle is configured

        // Mouse tracking for hover effects
        let mouseX = -1;
        let mouseY = -1;
        let isHoveringPatreon = false; // Track hover state

        // Notification class for temporary messages
        class Notification {
            constructor(text, duration = NOTIFICATION_DURATION) {
                this.text = text;
                this.duration = duration; // Duration in milliseconds
                this.startTime = Date.now();
            }

            isExpired() {
                return (Date.now() - this.startTime) > this.duration;
            }

            draw(index) {
                ctx.save();
                ctx.font = UI_FONT_STYLE;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                // Display below the hint text, stacked vertically
                ctx.fillText(this.text, HINT_X, NOTIFICATION_STACK_Y + index * NOTIFICATION_STACK_STEP);
                ctx.restore();
            }
        }

        // Resize canvas to fit window
        function resizeCanvas() {
            // Increase canvas size by multiplier in both dimensions
            canvas.width = window.innerWidth * CANVAS_SIZE_MULTIPLIER;
            canvas.height = window.innerHeight * CANVAS_SIZE_MULTIPLIER;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            spawnRadius = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) / 2 + SPAWN_RADIUS_EXTRA;

            // --- Dynamic Calculation based on Screen Size ---
            const minDimension = Math.min(canvas.width, canvas.height);

            // Adjust MAX_PARTICLES based on screen size (e.g., proportional to minDimension)
            isCacheReady = false;
            MAX_PARTICLES = Math.max(100, Math.min(600, Math.floor(100 + minDimension * 0.3)));

             // Adjust MIN_SIZE and MAX_SIZE based on screen size
            // Example scaling: Slightly smaller on smaller screens. Adjust factors as needed.
            MIN_SIZE = Math.max(10, Math.floor(minDimension * 0.015));
            MAX_SIZE = Math.max(15, Math.floor(minDimension * 0.025));
            // --- End Dynamic Calculation ---

            // Re-generate blur cache since sizes changed, using the current time hue shift
            makeEmojiVariantCache(currentTimeHueShift);
            // Recompute target points on resize
            computeTargetPoints();
            // Recreate stars for the new size
            createStars();
            // Update each particle's sun (target point)
            particles.forEach(p => {
                if (targetPoints.length > 0) {
                    const randomIndex = Math.floor(Math.random() * targetPoints.length);
                    p.sun = targetPoints[randomIndex];
                } else {
                    p.sun = { x: centerX, y: centerY };
                }
            });
        }

        // Pre-render blurred, sized, and hue-rotated emoji variants
        function makeEmojiVariantCache(baseHueShift = 0) {
            // Indicate cache is not ready during regeneration
            isCacheReady = false;
            console.time('makeEmojiVariantCache'); // Add timing
            const cache = [];
            const hueStep = 360 / HUE_LEVELS;
            const starHueMin = 60;
            const starHueMax = 210;
            const starHueStep = (STAR_HUE_LEVELS > 1) ? (starHueMax - starHueMin) / (STAR_HUE_LEVELS - 1) : 0;
            const imagePromises = []; // Store promises for image loading

            for (let e = 0; e < emojis.length; e++) {
                const emojiOrPath = emojis[e];
                const isStar = (e === STAR_INDEX);
                const isPatreon = (e === PATREON_INDEX);
                const isImagePath = typeof emojiOrPath === 'string' && (emojiOrPath.endsWith('.png') || emojiOrPath.endsWith('.jpg') || emojiOrPath.endsWith('.svg')); // Basic check

                if (isImagePath) {
                    // Preload the image
                    const img = new Image();
                    const promise = new Promise((resolve, reject) => {
                        img.onload = () => resolve({ img, index: e });
                        img.onerror = reject;
                        img.src = emojiOrPath;
                    });
                    imagePromises.push(promise);
                }
            }

            // Wait for all images to load before proceeding with cache generation
            Promise.all(imagePromises).then(loadedImagesData => {
                const loadedImages = {};
                loadedImagesData.forEach(data => {
                    loadedImages[data.index] = data.img;
                });

                for (let e = 0; e < emojis.length; e++) {
                    const emojiOrPath = emojis[e];
                    const isStar = (e === STAR_INDEX);
                    const isPatreon = (e === PATREON_INDEX);
                    const isImagePath = typeof emojiOrPath === 'string' && (emojiOrPath.endsWith('.png') || emojiOrPath.endsWith('.jpg') || emojiOrPath.endsWith('.svg')); // Basic check again
                    const sizeArr = [];

                    for (let s = 0; s < SIZE_LEVELS; s++) {
                        const size = MIN_SIZE + (s / (SIZE_LEVELS - 1)) * (MAX_SIZE - MIN_SIZE);
                        const hueArr = [];

                        // Create base canvas (size only, no blur)
                        const baseCanvas = document.createElement('canvas');
                        // Adjust canvas size based on whether it's an image or text emoji
                        // Images might need different base size calculations depending on aspect ratio
                        const baseSize = 2 * Math.ceil(size); // Keep this for now, might need adjustment for images
                        baseCanvas.width = baseCanvas.height = baseSize;
                        const baseCtx = baseCanvas.getContext('2d');

                        if (isImagePath) {
                            const img = loadedImages[e];
                            if (img) {
                                // Draw the loaded image centered onto the base canvas
                                // Maintain aspect ratio
                                const hRatio = baseCanvas.width / img.width;
                                const vRatio = baseCanvas.height / img.height;
                                const ratio = Math.min(hRatio, vRatio); // Use min ratio to fit within bounds
                                const drawWidth = img.width * ratio;
                                const drawHeight = img.height * ratio;
                                const drawX = (baseCanvas.width - drawWidth) / 2;
                                const drawY = (baseCanvas.height - drawHeight) / 2;
                                baseCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                            } else {
                                // Fallback or error handling if image didn't load
                                baseCtx.fillStyle = 'red'; // Indicate error
                                baseCtx.fillRect(0, 0, baseSize, baseSize);
                            }
                        } else {
                            // Handle text emojis as before
                            baseCtx.font = `${size}px Arial`;
                            baseCtx.textAlign = 'center';
                            baseCtx.textBaseline = 'middle';
                             // Set color for Patreon logo (if it were text) - no longer needed here
                            // if (isPatreon) { baseCtx.fillStyle = PATREON_ORANGE; }
                            baseCtx.fillText(emojiOrPath, baseCanvas.width / 2, baseCanvas.height / 2);
                        }

                        // --- Hue Variation Generation ---
                        if (isPatreon) {
                            // Patreon Icon (Image): Only store the base version, no hue shifts
                            hueArr.push(baseCanvas);
                             while (hueArr.length < HUE_LEVELS) { // Pad if needed (though only 1 is used)
                                hueArr.push(baseCanvas);
                             }
                        } else if (isStar) {
                            // Generate specific hues for stars (STAR_HUE_LEVELS)
                            const numHuesToGenerate = Math.max(1, STAR_HUE_LEVELS); // Ensure at least 1
                            for (let h = 0; h < numHuesToGenerate; h++) {
                                const hue = starHueMin + h * starHueStep;
                                // Always generate hue canvas for stars unless STAR_HUE_LEVELS is 1
                                if (STAR_HUE_LEVELS === 1) {
                                    hueArr.push(baseCanvas);
                                    break; // Only need base
                                }
                                const hueCanvas = document.createElement('canvas');
                                hueCanvas.width = hueCanvas.height = baseSize;
                                const hueCtx = hueCanvas.getContext('2d');
                                // Apply base shift + specific star hue
                                hueCtx.filter = `hue-rotate(${baseHueShift + hue}deg)`;
                                hueCtx.drawImage(baseCanvas, 0, 0); // Draw base onto filtered context
                                // No save/restore needed here
                                hueArr.push(hueCanvas);
                            }
                            // Pad if necessary (should match STAR_HUE_LEVELS)
                            while (hueArr.length < STAR_HUE_LEVELS) { 
                                hueArr.push(hueArr[0] || baseCanvas); // Prevent error if array empty
                            }
                        } else {
                            // Generate full spectrum hues for non-stars (HUE_LEVELS)
                            hueArr.push(baseCanvas); // Add base at index 0
                            for (let h = 1; h < HUE_LEVELS; h++) {
                                const hue = h * hueStep;
                                const hueCanvas = document.createElement('canvas');
                                hueCanvas.width = hueCanvas.height = baseSize;
                                const hueCtx = hueCanvas.getContext('2d');
                                // Apply base shift + regular hue step
                                hueCtx.filter = `hue-rotate(${baseHueShift + hue}deg)`;
                                hueCtx.drawImage(baseCanvas, 0, 0);
                                hueArr.push(hueCanvas);
                            }
                        }
                        // --- End Hue Variation Generation ---

                        sizeArr.push(hueArr);
                    }
                    cache.push(sizeArr);
                }
                console.timeEnd('makeEmojiVariantCache'); // End timing
                // Indicate cache is ready AFTER population is complete
                emojiVariantCache = cache;
                isCacheReady = true;
            }).catch(error => {
                 console.error("Error loading images for cache:", error);
                 // Handle image loading errors appropriately
                 isCacheReady = false; // Ensure cache is marked as not ready on error
            });
        }

        // Particle class
        class Particle {
            constructor() {
                this.x = 0;
                this.y = 0;
                this.vx = 0;
                this.vy = 0;
                this.sun = null;
                this.previousSun = null; // Store the previous target point
                this.sunChangeTime = null; // Timestamp of the last sun change
                this.emojiIndex = 0;
                this.size = 0;
                this.scaleFactor = 1; // Add scale factor property
                this.hueRotation = 0; // For stars: specific hue rotation value
                this.hueLevel = 0; // For non-stars: index into cached hues
                this.isPatreonParticle = false; // Flag for the special particle
                this.trail = []; // Initialize trail array
                this.reset(true);
            }

            reset(initial = false) {
                // Spawn outside the screen on a circle
                const theta = Math.random() * 2 * Math.PI;
                this.x = centerX + spawnRadius * Math.cos(theta);
                this.y = centerY + spawnRadius * Math.sin(theta);

                // Assign a random target point as the "sun"
                if (targetPoints.length > 0) {
                    const randomIndex = Math.floor(Math.random() * targetPoints.length);
                    this.sun = targetPoints[randomIndex];
                } else {
                    this.sun = { x: centerX, y: centerY };
                }

                // Initial velocity calculation
                const dx = this.sun.x - this.x;
                const dy = this.sun.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                // Calculate the angle towards the sun
                const angleToSun = Math.atan2(dy, dx);

                // Add a random offset to the angle
                const randomOffset = (Math.random() * 2 - 1) * PARTICLE_INITIAL_ANGLE_OFFSET;
                const finalAngle = angleToSun + randomOffset;

                // Calculate total speed - Doubled range [20, 40)
                const speed = PARTICLE_SPEED_MIN + Math.random() * (40 - PARTICLE_SPEED_MIN); // Max speed in range doubled to 40

                // Set velocity based on the final angle and speed
                this.vx = Math.cos(finalAngle) * speed;
                this.vy = Math.sin(finalAngle) * speed;

                // --- Emoji, Size, Scale, Hue Assignment ---
                // Keep current emoji if it's the special Patreon particle
                if (!this.isPatreonParticle) { 
                    this.emojiIndex = weightedEmojiIndices[Math.floor(Math.random() * weightedEmojiIndices.length)];
                    // Assign random size only to non-Patreon particles
                    this.size = MIN_SIZE + Math.random() * (MAX_SIZE - MIN_SIZE);
                } else {
                    // Patreon particle always gets MAX_SIZE
                    this.size = MAX_SIZE;
                }

                // Set scale factor based on emoji
                if (this.isPatreonParticle) {
                     this.scaleFactor = PATREON_SCALE_FACTOR;
                } else if (this.emojiIndex === STAR_INDEX) {
                    this.scaleFactor = STAR_PARTICLE_SCALE_FACTOR;
                } else {
                    this.scaleFactor = 1.5; // Scale for other non-star emojis
                }

                // Set hue level
                if (this.isPatreonParticle) {
                     this.hueLevel = 0; // Patreon always uses base hue (orange)
                } else if (this.emojiIndex === STAR_INDEX) {
                    // Stars: Choose a random pre-rendered star hue level
                    this.hueLevel = Math.floor(Math.random() * STAR_HUE_LEVELS);
                } else {
                    // Non-stars: Calculate index for pre-rendered hue cache
                    this.hueLevel = Math.floor(Math.random() * HUE_LEVELS);
                }
                // --- End Emoji Assignment ---

                this.previousSun = null; // Reset previous sun on particle reset
                this.sunChangeTime = null; // Reset timestamp on particle reset
            }

            // Helper function to calculate alpha based on distance to a given point
            calculateAlphaForSun(sunPoint, maxAlphaValue) {
                if (!sunPoint) return MIN_ALPHA; // Handle cases where sunPoint might be null

                const maxR = spawnRadius;
                const dx = this.x - sunPoint.x;
                const dy = this.y - sunPoint.y;
                const r = Math.sqrt(dx * dx + dy * dy);
                const norm = Math.max(0, Math.min(1, r / maxR));

                let alpha;
                if (norm > ALPHA_FADE_RADIUS) {
                    alpha = MIN_ALPHA;
                } else {
                    const fadeNorm = 1 - (norm / ALPHA_FADE_RADIUS);
                    alpha = MIN_ALPHA + fadeNorm * (maxAlphaValue - MIN_ALPHA);
                }
                return alpha;
            }

            update(deltaTime) {
                // Only apply gravity if enabled
                if (gravityEnabled) {
                    const dx = this.sun.x - this.x;
                    const dy = this.sun.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    const minDistSq = PARTICLE_MIN_DIST * PARTICLE_MIN_DIST;

                    // Avoid division by zero or tiny distances, and use cached min distance squared
                    if (distSq > 1e-6) { 
                        const actualDistSq = Math.max(distSq, minDistSq);
                        const dist = Math.sqrt(actualDistSq); // Need sqrt for force calculation direction
                        const forceMagnitude = PARTICLE_GRAVITY / actualDistSq; // Use squared distance here
                        // Apply force scaled by deltaTime
                        const forceScale = forceMagnitude * deltaTime / dist; // Pre-calculate scaling factor
                        this.vx += dx * forceScale;
                        this.vy += dy * forceScale;
                    }
                }

                // Apply velocity damping
                this.vx *= PARTICLE_DAMPING_FACTOR;
                this.vy *= PARTICLE_DAMPING_FACTOR;

                // --- Start: Enforce Minimum Speed ---
                const currentSpeedSq = this.vx * this.vx + this.vy * this.vy;
                const minSpeedSq = PARTICLE_MIN_ABS_SPEED * PARTICLE_MIN_ABS_SPEED;

                if (currentSpeedSq > 1e-6 && currentSpeedSq < minSpeedSq) { // Check if speed is below min but not zero
                    const currentSpeed = Math.sqrt(currentSpeedSq);
                    const scaleFactor = PARTICLE_MIN_ABS_SPEED / currentSpeed;
                    this.vx *= scaleFactor;
                    this.vy *= scaleFactor;
                }
                // --- End: Enforce Minimum Speed ---

                // Clamp velocity to maximum (using squared comparison)
                const maxVel = PARTICLE_MAX_VEL;
                const maxVelSq = maxVel * maxVel;
                const velSq = this.vx * this.vx + this.vy * this.vy; // Recalculate velSq after potential min speed boost
                if (velSq > maxVelSq) {
                    const vel = Math.sqrt(velSq); // Need sqrt only here for normalization
                    const clampFactor = maxVel / vel;
                    this.vx *= clampFactor;
                    this.vy *= clampFactor;
                }

                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;

                // Add current position to trail if it's the Patreon particle
                if (this.isPatreonParticle) {
                    this.trail.push({ x: this.x, y: this.y });
                    // Keep trail at the defined length
                    if (this.trail.length > PATREON_TRAIL_LENGTH) {
                        this.trail.shift(); // Remove the oldest point
                    }
                }

                // Reset if far off screen
                if (
                    this.x < -PARTICLE_OUT_BOUNDS || this.x > canvas.width + PARTICLE_OUT_BOUNDS ||
                    this.y < -PARTICLE_OUT_BOUNDS || this.y > canvas.height + PARTICLE_OUT_BOUNDS
                ) {
                    this.reset();
                }

                // Apply mouse interaction
                if (mouseX !== -1 && mouseY !== -1) {
                    const dx = this.x - mouseX;
                    const dy = this.y - mouseY;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < MOUSE_INTERACTION_RADIUS * MOUSE_INTERACTION_RADIUS && distSq > 1e-4) { // Added check for distSq > 1e-4
                        const dist = Math.sqrt(distSq);
                        
                        if (this.isPatreonParticle) {
                            // Attract Patreon particle TOWARDS the mouse
                            // Force proportional to distance (gentler pull when close)
                            const attractForce = MOUSE_ATTRACT_STRENGTH * dist; 
                            const forceScale = attractForce * deltaTime / dist; // Normalize direction vector
                            // Attract Patreon particle TOWARDS the mouse (subtract force component)
                            this.vx -= dx * forceScale;
                            this.vy -= dy * forceScale;
                        } else {
                            // Repel other particles AWAY from the mouse
                            // Force proportional to 1/distSq
                            const repelForce = MOUSE_REPEL_STRENGTH / (distSq); 
                            const forceScale = repelForce * deltaTime / dist; // Normalize direction vector
                            // Repel other particles AWAY from the mouse (add force component)
                            this.vx += dx * forceScale;
                            this.vy += dy * forceScale;
                        }
                    }
                }
            }

            draw() {
                // Don't draw if cache isn't ready
                if (!isCacheReady) return;

                const maxR = spawnRadius; // Keep maxR needed for helpers
                let sizeLevel = 0; // Initialize sizeLevel
                if (MAX_SIZE > MIN_SIZE) { // Prevent division by zero
                  sizeLevel = Math.round(((this.size - MIN_SIZE) / (MAX_SIZE - MIN_SIZE)) * (SIZE_LEVELS - 1));
                } // If MIN_SIZE === MAX_SIZE, sizeLevel remains 0, which is safe.
                
                // Clamp sizeLevel to ensure it's within bounds [0, SIZE_LEVELS - 1]
                sizeLevel = Math.max(0, Math.min(SIZE_LEVELS - 1, sizeLevel));

                // Determine the correct max alpha based on particle type
                const maxAlphaToUse = this.isPatreonParticle ? PATREON_MAX_ALPHA : MAX_ALPHA;

                // Alpha calculation (distance fade + transition)
                let finalAlpha;
                const now = Date.now();

                if (this.sunChangeTime && this.previousSun) {
                    const elapsedTransition = now - this.sunChangeTime;

                    if (elapsedTransition < ALPHA_TRANSITION_DURATION) {
                        // Still transitioning
                        const transitionProgress = elapsedTransition / ALPHA_TRANSITION_DURATION;

                        // Interpolate Alpha using the correct max alpha for each point
                        const alphaCurrent = this.calculateAlphaForSun(this.sun, maxAlphaToUse);
                        const alphaPrevious = this.calculateAlphaForSun(this.previousSun, maxAlphaToUse); // Use same maxAlpha for prev point for consistent transition
                        finalAlpha = alphaPrevious + (alphaCurrent - alphaPrevious) * transitionProgress;

                    } else {
                        // Transition finished
                        finalAlpha = this.calculateAlphaForSun(this.sun, maxAlphaToUse);
                        this.previousSun = null; // Clear previous sun data
                        this.sunChangeTime = null;
                    }
                } else {
                    // No transition happening
                    finalAlpha = this.calculateAlphaForSun(this.sun, maxAlphaToUse);
                }

                // Ensure indices are valid integers before accessing cache
                const validEmojiIndex = Math.max(0, Math.min(emojis.length - 1, Math.floor(this.emojiIndex)));
                // sizeLevel is already clamped and an integer
                const validHueLevel = Math.max(0, Math.min(HUE_LEVELS - 1, Math.floor(this.hueLevel)));

                // Retrieve the correct canvas from the cache
                // For non-stars, this includes pre-rendered hue.
                // For stars (hueLevel=0), this is the base (blur+size) canvas.
                const emojiCanvas = emojiVariantCache[validEmojiIndex][sizeLevel][validHueLevel];

                ctx.save();
                // Draw the trail *first* if it's the Patreon particle
                if (this.isPatreonParticle && this.trail.length > 1) {
                    // Get the base canvas for the Patreon icon
                    const baseEmojiCanvas = emojiVariantCache[validEmojiIndex]?.[sizeLevel]?.[validHueLevel];

                    if (baseEmojiCanvas) { // Only draw trail if we have the canvas
                        const baseWidth = baseEmojiCanvas.width;
                        const baseHeight = baseEmojiCanvas.height;
                        const trailLength = this.trail.length;

                        // --- Draw Trail Segments using Image ---
                        // Draw every fourth segment (i += 4) for reduced density
                        for (let i = 0; i < trailLength - 1; i += 4) { // Iterate from oldest to newest
                            const point = this.trail[i];
                            const trailProgress = i / (trailLength - 1); // 0 (oldest) to 1 (newest)

                            // Alpha fades out drastically (dimmest at tail, brightest near particle)
                            const trailAlpha = finalAlpha * Math.pow(trailProgress, 3.0) * 1.0; // Use trailProgress directly, high exponent

                            // Size shrinks slower (from 0.5x to 1x instead of 0x to 1x)
                            const trailScale = 0.5 + trailProgress * 0.5;
                            const trailWidth = baseWidth * this.scaleFactor * trailScale;
                            const trailHeight = baseHeight * this.scaleFactor * trailScale;
                            const trailX = point.x - trailWidth / 2;
                            const trailY = point.y - trailHeight / 2;

                             // Skip drawing if too small or transparent
                            if (trailWidth < 1 || trailHeight < 1 || trailAlpha <= 0.01) continue;

                            // Calculate hue for RGB effect
                            const hue = (Date.now() / 15 + i * (360 / trailLength)) % 360;

                            // Store current main alpha, set trail segment alpha, draw, restore main alpha
                            const currentGlobalAlpha = ctx.globalAlpha;
                            ctx.globalAlpha = Math.max(0, Math.min(1, trailAlpha)); // Apply calculated trail alpha

                            // Apply hue rotation filter with increased saturation and brightness
                            ctx.save(); // Save before applying filter
                            ctx.filter = `hue-rotate(${hue}deg) saturate(300%) brightness(150%)`;

                            ctx.drawImage(
                                baseEmojiCanvas,
                                trailX,
                                trailY,
                                trailWidth,
                                trailHeight
                            );

                            ctx.restore(); // Restore context state (removes filter)

                            ctx.globalAlpha = currentGlobalAlpha; // Restore original alpha for the next segment or main particle
                        }
                         // --- End Trail Segment Drawing ---
                    }
                    // Removed the old trail drawing logic (fillStyle, arc, shadow)
                }

                // Now, draw the main particle image (will be on top of trail if Patreon)
                if (emojiCanvas) {
                    ctx.save(); // Save context before applying glow and drawing main particle

                    // --- Start: Add subtle RGB Glow Effect for Patreon Particle ---
                    if (this.isPatreonParticle) {
                        const glowHue = (Date.now() / 20) % 360; // Slower hue cycle for glow
                        ctx.shadowBlur = 15; // Adjust blur amount as needed
                        ctx.shadowColor = `hsla(${glowHue}, 100%, 70%, 0.8)`; // Lighter, slightly transparent glow
                    }
                    // --- End: Add subtle RGB Glow Effect ---

                    // Calculate the final alpha once, right before drawing the image and trail
                    const maxAlphaToUse = this.isPatreonParticle ? PATREON_MAX_ALPHA : MAX_ALPHA;
                    let finalAlpha;
                    const now = Date.now();
                    if (this.sunChangeTime && this.previousSun) {
                         const elapsedTransition = now - this.sunChangeTime;
                         if (elapsedTransition < ALPHA_TRANSITION_DURATION) {
                              const transitionProgress = elapsedTransition / ALPHA_TRANSITION_DURATION;
                              const alphaCurrent = this.calculateAlphaForSun(this.sun, maxAlphaToUse);
                              const alphaPrevious = this.calculateAlphaForSun(this.previousSun, maxAlphaToUse);
                              finalAlpha = alphaPrevious + (alphaCurrent - alphaPrevious) * transitionProgress;
                         } else {
                              finalAlpha = this.calculateAlphaForSun(this.sun, maxAlphaToUse);
                              this.previousSun = null;
                              this.sunChangeTime = null;
                         }
                    } else {
                         finalAlpha = this.calculateAlphaForSun(this.sun, maxAlphaToUse);
                    }
                    // Ensure the finalAlpha is applied before drawing the image
                    ctx.globalAlpha = finalAlpha;

                    const destWidth = emojiCanvas.width * this.scaleFactor;
                    const destHeight = emojiCanvas.height * this.scaleFactor;
                    const destX = this.x - destWidth / 2;
                    const destY = this.y - destHeight / 2;
                    ctx.drawImage(
                        emojiCanvas,
                        destX,
                        destY,
                        destWidth,
                        destHeight
                    );

                    ctx.restore(); // Restore context (removes shadow effect for next draw)

                } else {
                    console.error("Failed to get emojiCanvas for:", { 
                        emojiIndex: this.emojiIndex, 
                        sizeLevel: sizeLevel 
                    });
                }

                ctx.restore(); // Restore the initial saved state
            }
        }

        // Function to get current local time in user's timezone
        function getCurrentLocalTime() {
            const now = new Date();
            // Format as 12-hour time with AM/PM in user's local timezone
            let hours = now.getHours();
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12; // Convert 0 to 12 for midnight
            return `${hours}:${minutes}`;
        }

        // Responsive font size based on canvas width
        function getResponsiveFontSize() {
            // You can tweak the multiplier for your preferred size
            return Math.max(RESPONSIVE_FONT_MIN, Math.min(canvas.width, canvas.height) * RESPONSIVE_FONT_MULTIPLIER);
        }

        // Define time string and compute target shape
        function computeTargetPoints() {
            // Create offscreen canvas
            const offscreenCanvas = document.createElement('canvas');
            const fontSize = getResponsiveFontSize();
            offscreenCanvas.width = canvas.width;
            offscreenCanvas.height = canvas.height;
            const offscreenCtx = offscreenCanvas.getContext('2d');

            // Get current local time
            const timeString = getCurrentLocalTime();

            // Render time string offscreen to compute target points
            offscreenCtx.font = `${fontSize}px Arial, sans-serif`;
            offscreenCtx.textAlign = 'center';
            offscreenCtx.textBaseline = 'middle';
            offscreenCtx.fillStyle = 'white';
            const textX = canvas.width / 2;
            const textY = canvas.height / 2;
            offscreenCtx.fillText(timeString, textX, textY);

            // Get pixel data
            const imageData = offscreenCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            targetPoints = [];

            // Sample pixels, but only keep points that are not too close to existing ones
            for (let y = 0; y < canvas.height; y += TARGET_POINT_STEP) {
                for (let x = 0; x < canvas.width; x += TARGET_POINT_STEP) {
                    const index = (y * canvas.width + x) * 4;
                    const alpha = data[index + 3];
                    if (alpha > TARGET_POINT_ALPHA_THRESHOLD) {
                        // Only add this point if it's not too close to any existing point
                        let tooClose = false;
                        for (let i = 0; i < targetPoints.length; i++) {
                            const dx = x - targetPoints[i].x;
                            const dy = y - targetPoints[i].y;
                            if (dx * dx + dy * dy < TARGET_POINT_MIN_DIST * TARGET_POINT_MIN_DIST) {
                                tooClose = true;
                                break;
                            }
                        }
                        if (!tooClose) {
                            targetPoints.push({ x, y });
                        }
                    }
                }
            }
        }

        // Draw target points for debugging
        function drawTargetPoints() {
            ctx.save();
            ctx.fillStyle = 'white';
            targetPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 1, 0, 2 * Math.PI);
                ctx.fill();
            });
            ctx.restore();
        }

        // Draw toggle hint with emojis
        function drawHint() {
            ctx.save();
            ctx.font = UI_FONT_STYLE;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`Press T to toggle target gravity ${gravityEnabled ? '✅' : '❌'}`, HINT_X, HINT_Y1);
            ctx.restore();
        }

        // Toggle gravity on key press with visual feedback
        document.addEventListener('keydown', (event) => {
            switch (event.key.toLowerCase()) {
                case 't':
                    gravityEnabled = !gravityEnabled;
                    break;
                case 'h':
                    hideUI = !hideUI;
                    break;
            }
        });

        // Update target points every minute change to reflect current time
        function scheduleNextTargetPointsUpdate() {
            const now = Date.now(); // Use Date.now() for consistency
            const date = new Date(now);
            const msToNextMinute = (60 - date.getSeconds()) * 1000 - date.getMilliseconds();
            setTimeout(() => {
                computeTargetPoints();
                const currentTime = Date.now(); // Get time *after* computeTargetPoints

                // --- Check for hour change and regenerate cache if needed ---
                const currentHour = new Date(currentTime).getHours();
                if (currentHour !== currentHourForCache) {
                    currentHourForCache = currentHour;
                    currentTimeHueShift = getTimeBasedHueShift();
                    console.log(`Hour changed to ${currentHour}. Regenerating cache with hue shift: ${currentTimeHueShift}deg`);
                    makeEmojiVariantCache(currentTimeHueShift);
                }
                // --- End hour check ---

                // After updating targetPoints, update each particle's sun (target point)
                particles.forEach(p => {
                    if (targetPoints.length > 0) {
                        const randomIndex = Math.floor(Math.random() * targetPoints.length);
                        const newSun = targetPoints[randomIndex];
                        // Only update previousSun if the sun actually changes
                        if (p.sun !== newSun) {
                           p.previousSun = p.sun ? { x: p.sun.x, y: p.sun.y } : null; // Store copy of old sun position
                           p.sun = newSun;
                           p.sunChangeTime = currentTime; // Set timestamp
                        }
                    } else {
                         // Handle case where there are no target points (shouldn't normally happen)
                         if (p.sun) { // Only trigger transition if it previously had a sun
                             p.previousSun = { x: p.sun.x, y: p.sun.y };
                             p.sunChangeTime = currentTime;
                         }
                        p.sun = { x: centerX, y: centerY };
                    }
                });
                scheduleNextTargetPointsUpdate();
                // Use Date.now() consistently and add buffer *after* calculation
            }, msToNextMinute + SCHEDULE_UPDATE_BUFFER);
        }
        scheduleNextTargetPointsUpdate();

        // Animation loop
        let patreonParticle = null; // Reference to the special particle

        function animate(time) {
            if (!startTime) startTime = time;
            const elapsed = time - startTime;
            const deltaTime = (time - lastTime) / 1000 || 0; // Ensure deltaTime is not NaN on first frame
            lastTime = time;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- Update and Draw Stars ---
            ctx.save();
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                // Update position
                star.x += star.vx * deltaTime;
                star.y += star.vy * deltaTime;

                // Wrap around screen edges
                if (star.x < 0) star.x += canvas.width;
                else if (star.x > canvas.width) star.x -= canvas.width;
                if (star.y < 0) star.y += canvas.height;
                else if (star.y > canvas.height) star.y -= canvas.height;

                // Draw star (using fillRect for simplicity)
                ctx.fillRect(star.x - star.size / 2, star.y - star.size / 2, star.size, star.size);
            });
            ctx.restore();
            // --- End Stars ---

            const targetParticles = Math.min(Math.floor((elapsed / SPAWN_DURATION) * MAX_PARTICLES), MAX_PARTICLES);
            // Remove excess particles if MAX_PARTICLES decreased
            if (particles.length > MAX_PARTICLES) {
                particles.length = MAX_PARTICLES; // Simply truncate the array
                if (debugParticleIndex !== null && debugParticleIndex >= particles.length) {
                   debugParticleIndex = null; // Reset debug index if it's now out of bounds
                }
            }
            // Add new particles if needed
            while (particles.length < targetParticles && particles.length < MAX_PARTICLES) {
                particles.push(new Particle());
            }

            // --- Delayed Patreon Particle Configuration ---
            // Check if the Patreon particle hasn't been configured yet,
            // if the initial spawn phase time has passed OR max particles reached,
            // and if the specific delay time has passed.
            if (!patreonParticleSpawned && 
                (elapsed >= SPAWN_DURATION || particles.length === MAX_PARTICLES) &&
                elapsed >= PATREON_SPAWN_DELAY && 
                particles.length > PATREON_PARTICLE_INDEX) 
            {
                patreonParticle = particles[PATREON_PARTICLE_INDEX];
                if (patreonParticle) { // Ensure the particle actually exists
                    patreonParticle.isPatreonParticle = true;
                    patreonParticle.emojiIndex = PATREON_INDEX;
                    patreonParticle.size = MAX_SIZE; // Still use max base size, scale factor handles visual size
                    patreonParticle.scaleFactor = PATREON_SCALE_FACTOR; // Apply the reduced scale factor
                    patreonParticle.hueLevel = 0; // Base hue
                    // Reset trail to start fresh when it spawns
                    patreonParticle.trail = []; 

                    // --- Reset Position and Velocity to Spawn from Edge ---
                    const theta = Math.random() * 2 * Math.PI;
                    patreonParticle.x = centerX + spawnRadius * Math.cos(theta);
                    patreonParticle.y = centerY + spawnRadius * Math.sin(theta);

                    // Assign a random target point as the "sun"
                    if (targetPoints.length > 0) {
                        const randomIndex = Math.floor(Math.random() * targetPoints.length);
                        patreonParticle.sun = targetPoints[randomIndex];
                    } else {
                        patreonParticle.sun = { x: centerX, y: centerY };
                    }
                    patreonParticle.previousSun = null; // Ensure no lingering transition alpha
                    patreonParticle.sunChangeTime = null;

                    // Initial velocity calculation (same logic as reset)
                    const dx = patreonParticle.sun.x - patreonParticle.x;
                    const dy = patreonParticle.sun.y - patreonParticle.y;
                    const angleToSun = Math.atan2(dy, dx);
                    const randomOffset = (Math.random() * 2 - 1) * PARTICLE_INITIAL_ANGLE_OFFSET;
                    const finalAngle = angleToSun + randomOffset;
                    const speed = PARTICLE_SPEED_MIN + Math.random() * (40 - PARTICLE_SPEED_MIN);
                    patreonParticle.vx = Math.cos(finalAngle) * speed;
                    patreonParticle.vy = Math.sin(finalAngle) * speed;
                    // --- End Reset Position and Velocity ---

                    patreonParticleSpawned = true; // Mark as spawned
                    console.log(`Patreon particle configured and spawned at ${elapsed.toFixed(0)}ms`);
                }
            }
            // --- End Delayed Configuration ---

            // Update all particles first
            particles.forEach(p => p.update(deltaTime));

            // Draw non-Patreon particles with potential hue shift
            particles.forEach((p, index) => {
                if (index !== PATREON_PARTICLE_INDEX) {
                    p.draw();
                }
            });

            // Draw Patreon particle last (if it exists) without the time-based shift
            if (patreonParticleSpawned && patreonParticle) { // Check spawn flag before drawing
                patreonParticle.draw();
            }

            // Draw debugging elements and UI only if not hidden
            if (!hideUI) {
                drawTargetPoints();
                drawHint();

                // After particles are spawned:
                if (particles.length > 0) {
                    // If no debug particle, or if it was reset (replaced), pick a new one
                    if (
                        debugParticleIndex === null ||
                        debugParticleIndex >= particles.length
                    ) {
                        debugParticleIndex = Math.floor(Math.random() * particles.length);
                    }
                    const p = particles[debugParticleIndex];
                    ctx.save();
                    ctx.strokeStyle = DEBUG_LINE_COLOR;
                    ctx.lineWidth = DEBUG_LINE_WIDTH;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.sun.x, p.sun.y);
                    ctx.stroke();
                    ctx.restore();

                    // If the particle is out of bounds (about to be reset), pick a new one next frame
                    if (
                        p.x < -PARTICLE_OUT_BOUNDS || p.x > canvas.width + PARTICLE_OUT_BOUNDS ||
                        p.y < -PARTICLE_OUT_BOUNDS || p.y > canvas.height + PARTICLE_OUT_BOUNDS
                    ) {
                        debugParticleIndex = null;
                    }
                }

                // Draw notifications
                notifications = notifications.filter(n => !n.isExpired());
                notifications.forEach((n, index) => n.draw(index));
            }

            requestAnimationFrame(animate);
        }

        // Initialize target points and start animation
        // First, determine initial hue shift before generating cache
        currentHourForCache = new Date().getHours();
        currentTimeHueShift = getTimeBasedHueShift();
        resizeCanvas(); // Now calls makeEmojiVariantCache with the initial shift
        window.addEventListener('resize', resizeCanvas);
        computeTargetPoints(); // computeTargetPoints is also called inside resizeCanvas, maybe remove one? Let's keep it for now.
        scheduleNextTargetPointsUpdate(); // Schedule the hourly check/update
        requestAnimationFrame(animate);

        // Function to generate stars
        function createStars() {
            stars.length = 0; // Clear existing stars
            for (let i = 0; i < NUM_STARS; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const speed = STAR_MIN_SPEED + Math.random() * (STAR_MAX_SPEED - STAR_MIN_SPEED);
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: STAR_MIN_SIZE + Math.random() * (STAR_MAX_SIZE - STAR_MIN_SIZE),
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed
                });
            }
        }

        // Function to update background color based on time
        function updateBackgroundColor() {
            const hour = new Date().getHours();
            let bgColor;

            // Define dark color palette based on time of day
            if (hour >= 22 || hour < 5) { // Late Night / Early Morning
                bgColor = '#030310'; // Very dark blue/purple
            } else if (hour >= 5 && hour < 7) { // Dawn
                bgColor = '#080818'; // Slightly lighter dark blue
            } else if (hour >= 7 && hour < 18) { // Daytime
                bgColor = '#101020'; // Dark greyish-blue
            } else if (hour >= 18 && hour < 20) { // Dusk
                bgColor = '#080515'; // Darkening blue/purple
            } else { // Evening (20 - 22)
                bgColor = '#050312'; // Darker purple/blue
            }

            document.body.style.backgroundColor = bgColor;
        }

        // Function to calculate hue shift based on time of day
        function getTimeBasedHueShift() {
            const hour = new Date().getHours();
            let hueShift = 0; // Default: no shift

            if (hour >= 22 || hour < 5) { // Late Night / Early Morning (Cooler Blues/Purples)
                hueShift = 45; // Shift towards blue/violet
            } else if (hour >= 5 && hour < 7) { // Dawn (Slightly cooler)
                hueShift = 15;
            } else if (hour >= 7 && hour < 18) { // Daytime (Neutral/Slightly Warm)
                hueShift = -15; // Shift slightly towards yellow/green from base
            } else if (hour >= 18 && hour < 20) { // Dusk (Warmer Oranges/Pinks)
                hueShift = -45;
            } else { // Evening (20 - 22) (Cooling down)
                hueShift = -30;
            }
            return hueShift;
        }

        // Initial setup calls
        updateBackgroundColor(); // Set initial background color
        setInterval(updateBackgroundColor, 60000); // Update background every minute

        // Click Handler for Patreon Link
        function handleCanvasClick(event) {
            if (!patreonParticle) return; // No particle to check

            const rect = canvas.getBoundingClientRect();
             // Adjust click coordinates based on canvas scaling/position if needed
             // For this setup (fixed canvas covering viewport), direct coordinates might work
             // Consider canvas CSS transform if applied
            const scaleX = canvas.width / rect.width;    // relationship bitmap vs. element for X
            const scaleY = canvas.height / rect.height;  // relationship bitmap vs. element for Y

            const clickX = (event.clientX - rect.left) * scaleX;   // scale mouse coordinates after they have
            const clickY = (event.clientY - rect.top) * scaleY;    // been adjusted to be relative to element

            // Get particle dimensions
            const p = patreonParticle;
            let particleWidth = 0;
            let particleHeight = 0;

            // Need to estimate size from cache if possible, or use MAX_SIZE as approximation
            // Let's approximate using MAX_SIZE for simplicity, refine if needed
             if (emojiVariantCache && emojiVariantCache[p.emojiIndex] && emojiVariantCache[p.emojiIndex][SIZE_LEVELS-1]) {
                 const approxLargestHueCanvas = emojiVariantCache[p.emojiIndex][SIZE_LEVELS-1][0]; // Use base hue
                 if(approxLargestHueCanvas) {
                    particleWidth = approxLargestHueCanvas.width * p.scaleFactor;
                    particleHeight = approxLargestHueCanvas.height * p.scaleFactor;
                 } 
             }
             // Fallback if cache check fails (use MAX_SIZE directly?)
             if(particleWidth === 0) { 
                 particleWidth = (2 * MAX_SIZE) * p.scaleFactor;
                 particleHeight = (2 * MAX_SIZE) * p.scaleFactor;
             }

            const particleLeft = p.x - particleWidth / 2;
            const particleTop = p.y - particleHeight / 2;

            // Check if click is within bounds
            if (
                patreonParticleSpawned && // Only check if spawned
                clickX >= particleLeft &&
                clickX <= particleLeft + particleWidth &&
                clickY >= particleTop &&
                clickY <= particleTop + particleHeight
            ) {
                window.open(PATREON_URL, '_blank');
            }
        }

        // Add click listener
        canvas.addEventListener('click', handleCanvasClick);

        // Mouse Move Listener for Hover Effect
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (event.clientX - rect.left) * scaleX;
            mouseY = (event.clientY - rect.top) * scaleY;

            let nowHovering = false;
            if (patreonParticleSpawned && patreonParticle) { // Check spawn flag
                const p = patreonParticle;
                let particleWidth = 0;
                let particleHeight = 0;

                // Estimate size (reuse logic from click handler - consider refactoring)
                if (emojiVariantCache && emojiVariantCache[p.emojiIndex] && emojiVariantCache[p.emojiIndex][SIZE_LEVELS-1]) {
                    const approxLargestHueCanvas = emojiVariantCache[p.emojiIndex][SIZE_LEVELS-1][0];
                    if (approxLargestHueCanvas) {
                        particleWidth = approxLargestHueCanvas.width * p.scaleFactor;
                        particleHeight = approxLargestHueCanvas.height * p.scaleFactor;
                    }
                }
                if (particleWidth === 0) {
                    particleWidth = (2 * MAX_SIZE) * p.scaleFactor;
                    particleHeight = (2 * MAX_SIZE) * p.scaleFactor;
                }

                const particleLeft = p.x - particleWidth / 2;
                const particleTop = p.y - particleHeight / 2;

                if (
                    mouseX >= particleLeft &&
                    mouseX <= particleLeft + particleWidth &&
                    mouseY >= particleTop &&
                    mouseY <= particleTop + particleHeight
                ) {
                    nowHovering = true;
                }
            }

            // Update cursor only if hover state changed
            if (nowHovering !== isHoveringPatreon) {
                canvas.style.cursor = nowHovering ? 'pointer' : 'default';
                isHoveringPatreon = nowHovering;
            }
        });

        // Mouse Leave Listener to reset cursor
        canvas.addEventListener('mouseleave', () => {
            if (patreonParticleSpawned && isHoveringPatreon) { // Check spawn flag
                canvas.style.cursor = 'default';
                isHoveringPatreon = false;
                mouseX = -1; // Reset mouse coords
                mouseY = -1;
            }
        });

        // --- Add Touch Event Listeners ---
        function updateMousePosFromEvent(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                // Use the first touch point
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.clientX !== undefined) {
                // Use mouse coordinates if available (for mousemove)
                clientX = event.clientX;
                clientY = event.clientY;
            } else {
                // If no coordinates found, reset
                mouseX = -1;
                mouseY = -1;
                return;
            }

            mouseX = (clientX - rect.left) * scaleX;
            mouseY = (clientY - rect.top) * scaleY;
        }

        canvas.addEventListener('touchstart', (event) => {
            event.preventDefault(); // Prevent default touch behavior like scrolling
            updateMousePosFromEvent(event);
        }, { passive: false });

        canvas.addEventListener('touchmove', (event) => {
            event.preventDefault(); // Prevent default touch behavior
            updateMousePosFromEvent(event);
        }, { passive: false });

        canvas.addEventListener('touchend', (event) => {
            // Reset mouse position when touch ends
            mouseX = -1;
            mouseY = -1;
            // Also reset hover state if touch ends
            if (isHoveringPatreon) {
                 canvas.style.cursor = 'default';
                 isHoveringPatreon = false;
            }
        });

        canvas.addEventListener('touchcancel', (event) => {
             // Handle cancelled touches similarly to touchend
             mouseX = -1;
             mouseY = -1;
             if (isHoveringPatreon) {
                 canvas.style.cursor = 'default';
                 isHoveringPatreon = false;
             }
        });
        // --- End Touch Event Listeners ---

    </script>
</body>
</html>