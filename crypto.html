<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Markets</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f5f5f5;
        }

        .table {
            --bs-table-bg: #2b2b2b;
            --bs-table-color: #f5f5f5;
            --bs-table-striped-bg: #3c3c3c;
            --bs-table-hover-bg: #4f4f4f;
        }

        .table-hover>tbody>tr:hover>* {
            --bs-table-accent-bg: #4f4f4f;
            color: #f5f5f5;
        }

        .modal-content {
            background-color: #2b2b2b;
            color: #f5f5f5;
        }

        .modal-header,
        .modal-footer {
            border-bottom: 1px solid #4f4f4f;
            border-top: 1px solid #4f4f4f;
        }

        .form-control,
        .form-select {
            background-color: #3c3c3c;
            color: #f5f5f5;
            border: 1px solid #4f4f4f;
        }

        .form-control:focus,
        .form-select:focus {
            background-color: #3c3c3c;
            color: #f5f5f5;
            border-color: #0d6efd;
            box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
        }

        .btn-primary {
            background-color: #0d6efd;
            border-color: #0d6efd;
        }

        .news-item {
            border-bottom: 1px solid #4f4f4f;
            padding-bottom: 1rem;
            margin-bottom: 1rem;
        }

        .news-item:last-child {
            border-bottom: none;
        }

        a {
            color: #58a6ff;
        }

        a:hover {
            color: #80baff;
        }

        .text-muted {
            color: #adb5bd !important;
        }

        .btn-close {
            filter: invert(1) grayscale(100%) brightness(200%);
        }

        .btn-group .btn {
            background-color: #3c3c3c;
            border-color: #4f4f4f;
            color: #f5f5f5;
        }

        .btn-group .btn.active {
            background-color: #0d6efd;
            border-color: #0d6efd;
        }

        .sortable {
            cursor: pointer;
            user-select: none;
        }

        .chart-container {
            position: relative;
            height: 45vh;
            width: 100%;
        }

        /* --- NEW --- */
        #newsFeed {
            height: 45vh;
            /* Match chart container height to prevent layout shifts */
            overflow-y: auto;
            /* Enable vertical scrolling */
            padding-right: 0.5rem;
            /* Add some space for the scrollbar */
        }

        /* Helper class to center the spinner */
        #newsFeed.loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding-right: 0;
            /* No padding needed when spinner is centered */
        }
    </style>
</head>

<body>

    <div class="container mt-5">
        <h1 class="mb-4">Crypto Markets</h1>
        <div class="row mb-4">
            <div class="col-md-4">
                <label for="cryptoCount" class="form-label">Top Cryptos to Display:</label>
                <input type="number" id="cryptoCount" class="form-control" value="100" min="10" max="250">
            </div>
        </div>
        <table class="table table-hover">
            <thead>
                <tr>
                    <th scope="col" class="sortable" data-sort-key="market_cap_rank">Rank</th>
                    <th scope="col" class="sortable" data-sort-key="name">Name</th>
                    <th scope="col" class="sortable" data-sort-key="current_price">Price</th>
                    <th scope="col" class="sortable" data-sort-key="price_change_percentage_24h">24h %</th>
                    <th scope="col" class="sortable" data-sort-key="price_change_percentage_7d_in_currency">7d %</th>
                    <th scope="col" class="sortable" data-sort-key="market_cap">Market Cap</th>
                </tr>
            </thead>
            <tbody id="cryptoTable">
                <!-- Data will be populated by JavaScript -->
            </tbody>
        </table>
    </div>

    <!-- Details Modal -->
    <div class="modal fade" id="detailsModal" tabindex="-1" aria-labelledby="detailsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="detailsModalLabel"></h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="row">
                        <div class="col-md-8">
                            <div class="d-flex justify-content-center mb-3">
                                <div id="timeframe-buttons" class="btn-group" role="group">
                                    <button type="button" class="btn timeframe-btn active" data-days="1">1D</button>
                                    <button type="button" class="btn timeframe-btn" data-days="7">7D</button>
                                    <button type="button" class="btn timeframe-btn" data-days="30">30D</button>
                                    <button type="button" class="btn timeframe-btn" data-days="90">90D</button>
                                    <button type="button" class="btn timeframe-btn" data-days="365">1Y</button>
                                </div>
                            </div>
                            <div class="chart-container">
                                <canvas id="priceChart"></canvas>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <h4>Recent News</h4>
                            <div id="newsFeed"></div>
                        </div>
                    </div>
                    <div class="row mt-4">
                        <div class="col-12">
                            <h4 class="border-top pt-3 mt-3">About <span id="coinDescriptionName"></span></h4>
                            <div id="coinDescription"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const cryptoTable = document.getElementById('cryptoTable');
        const cryptoCountInput = document.getElementById('cryptoCount');
        const detailsModal = new bootstrap.Modal(document.getElementById('detailsModal'));
        const detailsModalLabel = document.getElementById('detailsModalLabel');
        const priceChartCanvas = document.getElementById('priceChart');
        const newsFeed = document.getElementById('newsFeed');
        const timeframeButtons = document.getElementById('timeframe-buttons');
        const tableHeaders = document.querySelectorAll('th.sortable');
        const coinDescriptionDiv = document.getElementById('coinDescription');
        const coinDescriptionName = document.getElementById('coinDescriptionName');

        let chart;
        let sortState = { key: 'market_cap_rank', order: 'asc' };
        let allCryptos = [];
        let currentCoin = null;

        const debounce = (func, delay) => {
            let timeout;
            return function (...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        };

        const formatPrice = (price) => {
            if (price === null || typeof price === 'undefined') {
                return 'N/A';
            }
            if (price >= 1) {
                return price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }
            if (price < 0.01 && price > 0) {
                return price.toFixed(8);
            }
            return price.toFixed(4);
        };

        const fetchTopCryptos = async (count) => {
            try {
                const response = await fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${count}&page=1&sparkline=false&price_change_percentage=7d`);
                if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                allCryptos = await response.json();
                return allCryptos;
            } catch (error) {
                console.error("Error fetching top cryptos:", error);
                cryptoTable.innerHTML = `<tr><td colspan="6" class="text-center text-danger">Failed to load cryptocurrency data. The API may be unavailable.</td></tr>`;
                return [];
            }
        };

        const sortCryptos = (cryptos, key, order) => {
            return [...cryptos].sort((a, b) => {
                const valA = a[key];
                const valB = b[key];
                if (valA === null || valA === undefined) return 1;
                if (valB === null || valB === undefined) return -1;
                if (key === 'name') {
                    return order === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                } else {
                    return order === 'asc' ? valA - valB : valB - valA;
                }
            });
        };

        const updateSortIndicators = () => {
            tableHeaders.forEach(header => {
                const key = header.dataset.sortKey;
                header.innerHTML = header.innerHTML.replace(/ ▲| ▼/, '');
                if (key === sortState.key) {
                    const arrow = sortState.order === 'desc' ? '▼' : '▲';
                    header.innerHTML += ` ${arrow}`;
                }
            });
        };

        const renderTable = (cryptos) => {
            cryptoTable.innerHTML = '';
            if (cryptos.length === 0) return;
            cryptos.forEach((coin) => {
                const row = document.createElement('tr');
                row.style.cursor = 'pointer';
                const change7d = coin.price_change_percentage_7d_in_currency;
                row.innerHTML = `
                    <td>${coin.market_cap_rank}</td>
                    <td>
                        <img src="${coin.image}" alt="${coin.name}" width="24" height="24" class="me-2 rounded-circle">
                        ${coin.name} <span class="text-muted">${coin.symbol.toUpperCase()}</span>
                    </td>
                    <td>$${formatPrice(coin.current_price)}</td>
                    <td class="${coin.price_change_percentage_24h > 0 ? 'text-success' : 'text-danger'}">${coin.price_change_percentage_24h.toFixed(2)}%</td>
                    <td class="${change7d > 0 ? 'text-success' : 'text-danger'}">${change7d ? change7d.toFixed(2) + '%' : 'N/A'}</td>
                    <td>$${coin.market_cap.toLocaleString()}</td>
                `;
                row.addEventListener('click', () => showDetails(coin));
                cryptoTable.appendChild(row);
            });
            updateSortIndicators();
        };

        const fetchChartData = async (coinId, days) => {
            try {
                const response = await fetch(`https://api.coingecko.com/api/v3/coins/${coinId}/ohlc?vs_currency=usd&days=${days}`);
                if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                return await response.json();
            } catch (error) {
                console.error(`Error fetching chart data for ${days} days:`, error);
                return [];
            }
        };

        const calculateMACD = (ohlcData) => {
            const closingPrices = ohlcData.map(p => p[4]);
            if (closingPrices.length < 35) return null;
            const calculateEMA = (data, period) => {
                const k = 2 / (period + 1);
                let ema = [data[0]];
                for (let i = 1; i < data.length; i++) {
                    ema[i] = (data[i] * k) + (ema[i - 1] * (1 - k));
                }
                return ema;
            };
            const ema12 = calculateEMA(closingPrices, 12);
            const ema26 = calculateEMA(closingPrices, 26);
            const macdLine = ema12.map((val, i) => val - ema26[i]);
            const signalLine = calculateEMA(macdLine, 9);
            return { macdLine, signalLine };
        };

        const renderChart = (ohlcData, macdData, days) => {
            if (chart) chart.destroy();
            const labels = ohlcData.map(d => {
                const date = new Date(d[0]);
                return days == 1 ? date.toLocaleTimeString() : date.toLocaleDateString();
            });
            const priceData = ohlcData.map(d => d[4]);
            chart = new Chart(priceChartCanvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Price (USD)',
                        data: priceData,
                        borderColor: '#0d6efd',
                        backgroundColor: 'rgba(13, 110, 253, 0.1)',
                        yAxisID: 'y',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'MACD',
                        data: macdData.macdLine,
                        borderColor: '#198754',
                        yAxisID: 'y1',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Signal',
                        data: macdData.signalLine,
                        borderColor: '#dc3545',
                        yAxisID: 'y1',
                        tension: 0.1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { position: 'left', ticks: { color: '#f5f5f5' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                        y1: { type: 'linear', display: true, position: 'right', ticks: { color: '#f5f5f5' }, grid: { drawOnChartArea: false } },
                        x: { ticks: { color: '#f5f5f5', maxRotation: 0, autoSkip: true, maxTicksLimit: 7 }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }
                    },
                    plugins: { legend: { labels: { color: '#f5f5f5' } } },
                    interaction: { mode: 'index', intersect: false }
                }
            });
        };

        const fetchNews = async (coinSymbol) => {
            try {
                const response = await fetch(`https://min-api.cryptocompare.com/data/v2/news/?lang=EN&categories=${coinSymbol.toUpperCase()}`);
                if (!response.ok) throw new Error(`News API Error: ${response.statusText}`);
                const newsData = await response.json();
                if (newsData.Type !== 100 || !newsData.Data || newsData.Data.length === 0) {
                    return [];
                }
                return newsData.Data.slice(0, 5).map(article => ({
                    title: article.title,
                    source: article.source,
                    url: article.url
                }));
            } catch (error) {
                console.error("Error fetching news:", error);
                return [{ title: 'Could not fetch news headlines.', source: 'System Error', url: '#' }];
            }
        };

        const renderNews = (newsItems) => {
            newsFeed.classList.remove('loading'); // --- MODIFIED ---
            newsFeed.innerHTML = '';
            if (!newsItems || newsItems.length === 0) {
                newsFeed.innerHTML = `<p>No recent news found for this asset.</p>`;
                return;
            }
            newsItems.forEach(item => {
                const newsItemDiv = document.createElement('div');
                newsItemDiv.className = 'news-item';
                newsItemDiv.innerHTML = `<h6><a href="${item.url}" target="_blank" rel="noopener noreferrer">${item.title}</a></h6><small class="text-muted">${item.source}</small>`;
                newsFeed.appendChild(newsItemDiv);
            });
        };

        const fetchCoinDetails = async (coinId) => {
            try {
                const response = await fetch(`https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=false&community_data=false&developer_data=false&sparkline=false`);
                if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                const data = await response.json();
                return data.description.en;
            } catch (error) {
                console.error("Error fetching coin details:", error);
                return "<p>Could not load coin description.</p>";
            }
        };

        const renderDescription = (descriptionHtml) => {
            if (descriptionHtml && descriptionHtml.trim().length > 0) {
                coinDescriptionDiv.innerHTML = descriptionHtml;
                coinDescriptionDiv.querySelectorAll('a').forEach(a => {
                    const href = a.getAttribute('href');
                    if (href && href.startsWith('/')) {
                        a.setAttribute('href', `https://www.coingecko.com${href}`);
                        a.setAttribute('target', '_blank');
                        a.setAttribute('rel', 'noopener noreferrer');
                    }
                });
            } else {
                coinDescriptionDiv.innerHTML = '<p>No description available for this asset.</p>';
            }
        };

        const updateChart = async (days) => {
            const ctx = priceChartCanvas.getContext('2d');
            if (chart) chart.destroy();
            ctx.clearRect(0, 0, priceChartCanvas.width, priceChartCanvas.height);
            ctx.fillStyle = '#f5f5f5';
            ctx.textAlign = 'center';
            ctx.fillText("Loading chart data...", priceChartCanvas.width / 2, priceChartCanvas.height / 2);

            const ohlcData = await fetchChartData(currentCoin.id, days);
            if (ohlcData && ohlcData.length > 0) {
                const macdData = calculateMACD(ohlcData);
                if (macdData) {
                    renderChart(ohlcData, macdData, days);
                } else {
                    ctx.clearRect(0, 0, priceChartCanvas.width, priceChartCanvas.height);
                    ctx.fillText("Not enough data to calculate MACD for this timeframe.", priceChartCanvas.width / 2, priceChartCanvas.height / 2);
                }
            } else {
                ctx.clearRect(0, 0, priceChartCanvas.width, priceChartCanvas.height);
                ctx.fillText("Chart data not available from the API for this timeframe.", priceChartCanvas.width / 2, priceChartCanvas.height / 2);
            }
        };

        const showDetails = async (coin) => {
            currentCoin = coin;
            detailsModalLabel.textContent = `${coin.name} (${coin.symbol.toUpperCase()}) Details`;

            // --- MODIFIED ---: Add loading class to center spinner
            newsFeed.classList.add('loading');
            newsFeed.innerHTML = '<div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div>';
            coinDescriptionName.textContent = coin.name;
            coinDescriptionDiv.innerHTML = '<div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div>';

            detailsModal.show();

            timeframeButtons.querySelector('.active').classList.remove('active');
            timeframeButtons.querySelector('[data-days="1"]').classList.add('active');

            updateChart(1);
            const newsPromise = fetchNews(coin.symbol);
            const descriptionPromise = fetchCoinDetails(coin.id);

            const [news, description] = await Promise.all([newsPromise, descriptionPromise]);

            renderNews(news);
            renderDescription(description);
        };

        timeframeButtons.addEventListener('click', (event) => {
            const target = event.target;
            if (target.matches('.timeframe-btn')) {
                timeframeButtons.querySelector('.active').classList.remove('active');
                target.classList.add('active');
                const days = target.dataset.days;
                if (currentCoin) {
                    updateChart(days);
                }
            }
        });

        const initialize = async () => {
            const count = cryptoCountInput.value;
            cryptoTable.innerHTML = `<tr><td colspan="6" class="text-center"><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div></td></tr>`;
            await fetchTopCryptos(count);
            const sortedCryptos = sortCryptos(allCryptos, sortState.key, sortState.order);
            renderTable(sortedCryptos);
        };

        const debouncedInit = debounce(initialize, 500);
        cryptoCountInput.addEventListener('input', debouncedInit);

        tableHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const newKey = header.dataset.sortKey;
                if (sortState.key === newKey) {
                    sortState.order = sortState.order === 'asc' ? 'desc' : 'asc';
                } else {
                    sortState.key = newKey;
                    sortState.order = (newKey === 'name' || newKey === 'market_cap_rank') ? 'asc' : 'desc';
                }
                const sortedCryptos = sortCryptos(allCryptos, sortState.key, sortState.order);
                renderTable(sortedCryptos);
            });
        });

        initialize();
    </script>
</body>

</html>